glXMakeCurrent:
    SDL_GLContext glctx = NULL;
    uint64_t fake_ctx = *trace_get_uint(trace_get_arg(command, 2));
    if (fake_ctx) {
        glctx = (SDL_GLContext)replay_get_real_object(ctx, ReplayObjType_GLXContext, fake_ctx);
        if (!glctx) {
            inspect_add_error(inspect_command, "Invalid GLX context.");
            RETURN;
        }
    }
    
    if (SDL_GL_MakeCurrent(ctx->window, glctx) < 0) {
        inspect_add_error(inspect_command, "Unable to make a context current.");
        RETURN;
    }
    
    if (glctx) {
        reload_gl_funcs(ctx);
        ctx->_current_context = glctx;
        //TODO: Hack to initialize VAO 0
        update_vao(ctx, inspect_command);
    } else {
        reset_gl_funcs(ctx);
        ctx->_current_context = NULL;
    }
    
    //Seems to be messing up the front buffer.
    //But the front buffer is still sometimes black when it should not be.
    /*SDL_GL_SetSwapInterval(0)*/

glXSwapIntervalEXT:
    ;

glXSwapIntervalMESA:
    ;

glXSwapIntervalSGI:
    ;

glXGetProcAddressARB:
    ;

glXGetProcAddress:
    ;

glXQueryExtension:
    ;

glXQueryVersion:
    ;

glXChooseVisual:
    ;

glXChooseFBConfig:
    ;

glXGetFBConfigs:
    ;

glXGetFBConfigAttrib:
    ;

glXGetVisualFromFBConfig:
    ;

glXChooseFBConfigSGIX:
    ;

glXGetFBConfigAttribSGIX:
    ;

glXGetVisualFromFBConfigSGIX:
    ;

glXGetClientString:
    ;

glXCreateContext:
    SDL_GLContext shareList = NULL;
    if (*trace_get_ptr(trace_get_arg(command, 2))) {
        shareList = (SDL_GLContext)replay_get_real_object(ctx,
                                                          ReplayObjType_GLXContext,
                                                          *trace_get_ptr(trace_get_arg(command, 2)));
        if (!shareList) {
            inspect_add_error(inspect_command, "Invalid share list.");
            RETURN;
        }
    }
    
    SDL_GLContext last_ctx = SDL_GL_GetCurrentContext();
    if (shareList) {
        SDL_GL_MakeCurrent(ctx->window, shareList);
        SDL_GL_SetAttribute(SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 1);
    } else {
        SDL_GL_SetAttribute(SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 0);
    }
    
    SDL_GLContext res = SDL_GL_CreateContext(ctx->window);
    if (!res) {
        inspect_add_error(inspect_command, "Unable to create context: %s", SDL_GetError());
        SDL_GL_MakeCurrent(ctx->window, last_ctx);
        RETURN;
    }
    replay_create_object(ctx, ReplayObjType_GLXContext, (uint64_t)res, *trace_get_ptr(&command->ret));
    
    SDL_GL_MakeCurrent(ctx->window, last_ctx);

glXCreateContextAttribsARB:
    int last_major, last_minor, last_flags, last_profile;
    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, &last_major);
    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, &last_minor);
    SDL_GL_GetAttribute(SDL_GL_CONTEXT_FLAGS, &last_flags);
    SDL_GL_GetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, &last_profile);
    
    int major = last_major;
    int minor = last_minor;
    int flags = 0;
    int profile = 0;
    
    int64_t* attribs = trace_get_int(trace_get_arg(command, 4));
    while (*attribs) {
        int attr = *(attribs++);
        if (attr == GLX_CONTEXT_MAJOR_VERSION_ARB) {
            major = *(attribs++);
        } else if (attr == GLX_CONTEXT_MINOR_VERSION_ARB) {
            minor = *(attribs++);
        } else if (attr == GLX_CONTEXT_FLAGS_ARB) {
            int glx_flags = *(attribs++);
            flags = 0;
            if (glx_flags & GLX_CONTEXT_DEBUG_BIT_ARB)
                flags |= SDL_GL_CONTEXT_DEBUG_FLAG;
            if (glx_flags & GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB)
                flags |= SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG;
        } else if (attr == GLX_CONTEXT_PROFILE_MASK_ARB) {
            int mask = *(attribs++);
            profile = 0;
            if (mask & GLX_CONTEXT_CORE_PROFILE_BIT_ARB)
                profile = SDL_GL_CONTEXT_PROFILE_CORE;
            if (mask & GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB)
                profile = SDL_GL_CONTEXT_PROFILE_COMPATIBILITY;
        } else {
            inspect_add_warning(inspect_command, "Unhandled attribute: %d", attr);
            attribs++;
        }
    }
    
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, major);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, minor);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, flags);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, profile);
    
    SDL_GLContext share_ctx = NULL;
    if (gl_param_GLXContext(command, 2)) {
        share_ctx = (SDL_GLContext)replay_get_real_object(ctx,
                                                          ReplayObjType_GLXContext,
                                                          gl_param_GLXContext(command, 2));
        if (!share_ctx) {
            inspect_add_error(inspect_command, "Invalid share context.");
            RETURN;
        }
    }
    
    SDL_GLContext last_ctx = SDL_GL_GetCurrentContext();
    if (share_ctx) {
        SDL_GL_MakeCurrent(ctx->window, share_ctx);
        SDL_GL_SetAttribute(SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 1);
    } else {
        SDL_GL_SetAttribute(SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 0);
    }
    
    SDL_GLContext res = SDL_GL_CreateContext(ctx->window);
    if (!res) {
        inspect_add_error(inspect_command, "Unable to create context: %s", SDL_GetError());
        SDL_GL_MakeCurrent(ctx->window, last_ctx);
        RETURN;
    }
    replay_create_object(ctx, ReplayObjType_GLXContext, (uint64_t)res, *trace_get_uint(&command->ret));
    
    SDL_GL_MakeCurrent(ctx->window, last_ctx);
    
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, last_major);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, last_minor);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, last_flags);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, last_profile);

glXQueryExtensionsString:
    ;

glXDestroyContext:
    SDL_GLContext glctx = (GLXContext)replay_get_real_object(ctx,
                                                             ReplayObjType_GLXContext,
                                                             *trace_get_ptr(trace_get_arg(command, 1)));
    if (!glctx) {
        inspect_add_error(inspect_command, "Invalid context.");
        RETURN;
    }
    
    SDL_GL_DeleteContext(glctx);
    replay_destroy_object(ctx, ReplayObjType_GLXContext, *trace_get_ptr(trace_get_arg(command, 1)));

glXSwapBuffers:
    if (!ctx->_current_context) {
        inspect_add_error(inspect_command, "No current OpenGL context.");
        RETURN;
    }
    SDL_GL_SwapWindow(ctx->window);
    replay_get_front_color(ctx, inspect_command);

glSetContextCapsWIP15:
    ;

glClear:
    GLbitfield mask = gl_param_GLbitfield(command, 0);
    real(mask);
    if (mask & GL_COLOR_BUFFER_BIT)
        update_drawbuffer(ctx, inspect_command, GL_COLOR, 0);
    if (mask & GL_DEPTH_BUFFER_BIT)
        update_drawbuffer(ctx, inspect_command, GL_DEPTH, 0);

glGenTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, textures);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLTexture, textures[i], fake[i]);
        inspect_act_gen_tex(&inspect_command->state, fake[i]);
    }

glDeleteTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i)
        if (!(textures[i] = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake[i]))) {
            inspect_add_error(inspect_command, "Invalid texture being deleted.");
        } else {
            inspect_act_del_tex(&inspect_command->state, fake[i]);
            replay_destroy_object(ctx, ReplayObjType_GLTexture, fake[i]);
        }
    
    real(n, textures);

glBindTexture:
    GLuint target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint real_tex = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake);
    if (!real_tex && fake)
        inspect_add_error(inspect_command, "Invalid texture being bound.");
    real(target, real_tex);

glTexImage1D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint internalFormat = gl_param_GLint(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLint border = gl_param_GLint(command, 4);
    GLenum format = gl_param_GLenum(command, 5);
    GLenum type = gl_param_GLenum(command, 6);
    const void* data = gl_param_data(command, 7);
    real(target, level, internalFormat, width, border, format, type, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glCompressedTexImage1D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLenum internalformat = gl_param_GLenum(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLint border = gl_param_GLint(command, 4);
    GLsizei imageSize = gl_param_GLsizei(command, 5);
    const void* data = gl_param_data(command, 6);
    real(target, level, internalformat, width, border, imageSize, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexSubImage1D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint xoffset = gl_param_GLint(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLenum format = gl_param_GLenum(command, 4);
    GLenum type = gl_param_GLenum(command, 5);
    const void* data = gl_param_data(command, 6);
    real(target, level, xoffset, width, format, type, data);
    replay_get_tex_data(ctx, inspect_command, target, level);

glCompressedTexSubImage1D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint xoffset = gl_param_GLint(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLenum format = gl_param_GLenum(command, 4);
    GLsizei imageSize = gl_param_GLsizei(command, 5);
    const void* data = gl_param_data(command, 6);
    real(target, level, xoffset, width, format, imageSize, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexImage2D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint internalFormat = gl_param_GLint(command, 2);
    GLsizei width = gl_param_GLenum(command, 3);
    GLsizei height = gl_param_GLenum(command, 4);
    GLint border = gl_param_GLenum(command, 5);
    GLenum format = gl_param_GLenum(command, 6);
    GLenum type = gl_param_GLenum(command, 7);
    const void* data = gl_param_data(command, 8);
    real(target, level, internalFormat, width, height, border, format, type, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glCompressedTexImage2D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLenum internalformat = gl_param_GLenum(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLsizei height = gl_param_GLsizei(command, 4);
    GLint border = gl_param_GLint(command, 5);
    GLsizei imageSize = gl_param_GLsizei(command, 6);
    const void* data = gl_param_data(command, 7);
    real(target, level, internalformat, width, height, border, imageSize, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexSubImage2D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint xoffset = gl_param_GLint(command, 2);
    GLint yoffset = gl_param_GLint(command, 3);
    GLsizei width = gl_param_GLsizei(command, 4);
    GLsizei height = gl_param_GLsizei(command, 5);
    GLenum format = gl_param_GLenum(command, 6);
    GLenum type = gl_param_GLenum(command, 7);
    const void* data = gl_param_data(command, 8);
    real(target, level, xoffset, yoffset, width, height, format, type, data);
    replay_get_tex_data(ctx, inspect_command, target, level);

glCompressedTexSubImage2D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint xoffset = gl_param_GLint(command, 2);
    GLint yoffset = gl_param_GLint(command, 3);
    GLsizei width = gl_param_GLsizei(command, 4);
    GLsizei height = gl_param_GLsizei(command, 5);
    GLenum format = gl_param_GLenum(command, 6);
    GLsizei imageSize = gl_param_GLsizei(command, 7);
    const void* data = gl_param_data(command, 8);
    real(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexImage3D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint internalFormat = gl_param_GLint(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLsizei height = gl_param_GLsizei(command, 4);
    GLsizei depth = gl_param_GLsizei(command, 5);
    GLint border = gl_param_GLsizei(command, 6);
    GLenum format = gl_param_GLenum(command, 7);
    GLenum type = gl_param_GLenum(command, 8);
    const void* data = gl_param_data(command, 9);
    real(target, level, internalFormat, width, height, depth, border, format, type, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glCompressedTexImage3D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLenum internalformat = gl_param_GLenum(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLsizei height = gl_param_GLsizei(command, 4);
    GLsizei depth = gl_param_GLsizei(command, 5);
    GLint border = gl_param_GLint(command, 6);
    GLsizei imageSize = gl_param_GLsizei(command, 7);
    const void* data = gl_param_data(command, 8);
    real(target, level, internalformat, width, height, depth, border, imageSize, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexSubImage3D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint xoffset = gl_param_GLint(command, 2);
    GLint yoffset = gl_param_GLint(command, 3);
    GLint zoffset = gl_param_GLint(command, 4);
    GLsizei width = gl_param_GLsizei(command, 5);
    GLsizei height = gl_param_GLsizei(command, 6);
    GLsizei depth = gl_param_GLsizei(command, 7);
    GLenum format = gl_param_GLenum(command, 8);
    GLenum type = gl_param_GLenum(command, 9);
    const void* data = gl_param_data(command, 10);
    real(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
    replay_get_tex_data(ctx, inspect_command, target, level);

glCompressedTexSubImage3D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint xoffset = gl_param_GLint(command, 2);
    GLint yoffset = gl_param_GLint(command, 3);
    GLint zoffset = gl_param_GLint(command, 4);
    GLsizei width = gl_param_GLsizei(command, 5);
    GLsizei height = gl_param_GLsizei(command, 6);
    GLsizei depth = gl_param_GLsizei(command, 7);
    GLenum format = gl_param_GLenum(command, 8);
    GLsizei imageSize = gl_param_GLsizei(command, 9);
    const void* data = gl_param_data(command, 10);
    real(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexImage2DMultisample:
    GLenum target = gl_param_GLenum(command, 0);
    GLsizei samples = gl_param_GLsizei(command, 1);
    GLenum internalformat = gl_param_GLenum(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLsizei height = gl_param_GLsizei(command, 4);
    GLboolean fixedsamplelocations = gl_param_GLboolean(command, 5);
    real(target, samples, internalformat, width, height, fixedsamplelocations);
    replay_get_tex_params(ctx, inspect_command, target);

glTexImage3DMultisample:
    GLenum target = gl_param_GLenum(command, 0);
    GLsizei samples = gl_param_GLsizei(command, 1);
    GLenum internalformat = gl_param_GLenum(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLsizei height = gl_param_GLsizei(command, 4);
    GLsizei depth = gl_param_GLsizei(command, 5);
    GLboolean fixedsamplelocations = gl_param_GLboolean(command, 6);
    real(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    replay_get_tex_params(ctx, inspect_command, target);

glGenerateMipmap:
    GLenum target = gl_param_GLenum(command, 0);
    real(target);
    
    GLint w, h, d;
    F(glGetTexLevelParameteriv)(target, 0, GL_TEXTURE_WIDTH, &w);
    F(glGetTexLevelParameteriv)(target, 0, GL_TEXTURE_HEIGHT, &h);
    F(glGetTexLevelParameteriv)(target, 0, GL_TEXTURE_DEPTH, &d);
    //TODO: Add more targets
    switch (target) {
    case GL_TEXTURE_1D:
        for (GLsizei i = 0; w; i++, w/=2)
            replay_get_tex_data(ctx, inspect_command, target, i);
    case GL_TEXTURE_2D:
        for (GLsizei i = 0; w && h; i++, w/=2, h/=2)
            replay_get_tex_data(ctx, inspect_command, target, i);
    case GL_TEXTURE_3D:
        for (GLsizei i = 0; w && h && d; i++, w/=2, h/=2, d/=2)
            replay_get_tex_data(ctx, inspect_command, target, i);
    }

glTexParameterf:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    GLfloat param = gl_param_GLfloat(command, 2);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameteri:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    GLint param = gl_param_GLint(command, 2);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameterfv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    double* paramsd = trace_get_double(trace_get_arg(command, 2));
    GLfloat params[4];
    if (pname==GL_TEXTURE_BORDER_COLOR || pname==GL_TEXTURE_SWIZZLE_RGBA)
        for (size_t i = 0; i < 4; i++)
            params[i] = paramsd[i];
    else
        params[0] = paramsd[0];
    
    real(target, pname, params);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameteriv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    int64_t* params64 = trace_get_int(trace_get_arg(command, 2));
    GLint params[4];
    if (pname==GL_TEXTURE_BORDER_COLOR || pname==GL_TEXTURE_SWIZZLE_RGBA)
        for (size_t i = 0; i < 4; i++)
            params[i] = params64[i];
    else
        params[0] = params64[0];
    
    real(target, pname, params);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameterIiv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    int64_t* params64 = trace_get_int(trace_get_arg(command, 2));
    GLint params[4];
    if (pname==GL_TEXTURE_BORDER_COLOR || pname==GL_TEXTURE_SWIZZLE_RGBA)
        for (size_t i = 0; i < 4; i++)
            params[i] = params64[i];
    else
        params[0] = params64[0];
    
    real(target, pname, params);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameterIuiv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    uint64_t* params64 = trace_get_uint(trace_get_arg(command, 2));
    GLuint params[4];
    if (pname==GL_TEXTURE_BORDER_COLOR || pname==GL_TEXTURE_SWIZZLE_RGBA)
        for (size_t i = 0; i < 4; i++)
            params[i] = params64[i];
    else
        params[0] = params64[0];
    
    real(target, pname, params);
    replay_get_tex_params(ctx, inspect_command, target);

glGenBuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, buffers);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLBuffer, buffers[i], fake[i]);
        inspect_act_gen_buf(&inspect_command->state, fake[i]);
    }

glDeleteBuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i) {
        if (!(buffers[i] = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake[i]))) {
            inspect_add_error(inspect_command, "Invalid buffer being deleted.");
        } else {
            inspect_act_del_buf(&inspect_command->state, fake[i]);
            replay_destroy_object(ctx, ReplayObjType_GLBuffer, fake[i]);
        }
    }
    
    real(n, buffers);

glBindBuffer:
    GLenum target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint real_buf = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake);
    if (!real_buf && fake) {
        inspect_add_error(inspect_command, "Invalid buffer being bound.");
        RETURN;
    }
    real(target, real_buf);

glBindBufferBase:
    GLenum target = gl_param_GLenum(command, 0);
    GLuint index = gl_param_GLuint(command, 1);
    GLuint fake = gl_param_GLuint(command, 2);
    GLuint buf = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake);
    if (!buf && fake) {
        inspect_add_error(inspect_command, "Invalid buffer being bound.");
        RETURN;
    }
    real(target, index, buf);

glBindBufferRange:
    GLenum target = gl_param_GLenum(command, 0);
    GLuint index = gl_param_GLuint(command, 1);
    GLuint fake = gl_param_GLuint(command, 2);
    GLuint buf = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake);
    if (!buf && fake) {
        inspect_add_error(inspect_command, "Invalid buffer being bound.");
        RETURN;
    }
    int64_t offset = gl_param_GLintptr(command, 3);
    int64_t size = gl_param_GLsizeiptr(command, 4);
    real(target, index, buf, offset, size);

glBufferData:
    GLuint target = gl_param_GLenum(command, 0);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 1);
    const void* data = gl_param_data(command, 2);
    GLenum usage = gl_param_GLenum(command, 3);
    real(target, size, data, usage);
    inspect_act_buf_data(&inspect_command->state, get_bound_buffer(ctx, target), size, data, usage);

glBufferSubData:
    GLuint target = gl_param_GLenum(command, 0);
    GLintptr offset = gl_param_GLintptr(command, 1);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 2);
    const void* data = gl_param_data(command, 3);
    real(target, offset, size, data);
    inspect_act_buf_sub_data(&inspect_command->state, get_bound_buffer(ctx, target), offset, size, data);

glMappedBufferDataWIP15:
    GLuint target = gl_param_GLenum(command, 0);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 1);
    const void* data = gl_param_data(command, 2);
    
    F(glUnmapBuffer)(target);
    F(glBufferSubData)(target, 0, size, data);
    inspect_act_buf_sub_data(&inspect_command->state, get_bound_buffer(ctx, target), 0, size, data);

glUnmapBuffer:
    ;

glCreateShader:
    GLenum type = gl_param_GLenum(command, 0);
    GLuint real_shdr = F(glCreateShader)(type);
    GLuint fake = trace_get_uint(&command->ret)[0];
    replay_create_object(ctx, ReplayObjType_GLShader, real_shdr, fake);
    inspect_act_new_shdr(&inspect_command->state, fake, type);

glDeleteShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr) {
        inspect_add_error(inspect_command, "Invalid shader.");
        RETURN;
    }
    
    F(glDeleteShader)(real_shdr);
    
    replay_destroy_object(ctx, ReplayObjType_GLShader, fake);
    inspect_act_del_shdr(&inspect_command->state, fake);

glShaderSource:
    GLuint fake = gl_param_GLuint(command, 0);
    GLsizei count = gl_param_GLsizei(command, 1);
    char** sources = gl_param_string_array(command, 2);
    
    GLuint shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        RETURN;
    }
    
    if (trace_get_arg(command, 3)->count == 0) {
        real(shader, 1, (const GLchar*const*)sources, NULL);
        inspect_act_shdr_source(&inspect_command->state, fake, count, (const char*const*)sources);
    } else {
        uint64_t* lengths64 = trace_get_uint(trace_get_arg(command, 3));
        
        GLint lengths[count];
        for (GLsizei i = 0; i < count; i++) {
            lengths[i] = lengths64[i];
        }
        
        real(shader, count, (const GLchar*const*)sources, lengths);
        
        char* new_sources[count];
        for (GLsizei i = 0; i < count; i++) {
            new_sources[i] = malloc(lengths[i]+1);
            memcpy(new_sources[i], sources[i], lengths[i]);
            new_sources[i][lengths[i]] = 0;
        }
        
        inspect_act_shdr_source(&inspect_command->state, fake, count, (const char*const*)new_sources);
        
        for (GLsizei i = 0; i < count; i++)
            free(new_sources[i]);
    }

glCompileShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr) {
        inspect_add_error(inspect_command, "Invalid shader.");
        RETURN;
    }
    
    real(real_shdr);
    
    GLint status;
    F(glGetShaderiv)(real_shdr, GL_COMPILE_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Unable to compile shader.");
    
    GLint len;
    F(glGetShaderiv)(real_shdr, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetShaderInfoLog)(real_shdr, len, NULL, info_log);
    
    inspect_act_set_shdr_info_log(&inspect_command->state, fake, info_log);
    
    free(info_log);

glCreateProgram:
    GLuint real_program = F(glCreateProgram)();
    GLuint fake = trace_get_uint(&command->ret)[0];
    replay_create_object(ctx, ReplayObjType_GLProgram, real_program, fake);
    inspect_act_new_prog(&inspect_command->state, fake);

glDeleteProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    
    real(real_program);
    
    replay_destroy_object(ctx, ReplayObjType_GLProgram, fake);
    inspect_act_del_prog(&inspect_command->state, fake);

glAttachShader:
    GLuint fake_program = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_program);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    
    GLuint fake_shader = gl_param_GLuint(command, 1);
    GLuint real_shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake_shader);
    if (!real_shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        RETURN;
    }
    
    real(real_program, real_shader);
    
    inspect_act_attach_shdr(&inspect_command->state, fake_program, fake_shader);

glDetachShader:
    GLuint fake_program = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_program);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    
    GLuint fake_shader = gl_param_GLuint(command, 1);
    GLuint real_shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake_shader);
    if (!real_shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        RETURN;
    }
    
    real(real_program, real_shader);
    
    inspect_act_detach_shdr(&inspect_command->state, fake_program, fake_shader);

glLinkProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    
    real(real_program);
    
    GLint status;
    F(glGetProgramiv)(real_program, GL_LINK_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Unable to link program.");
    
    GLint len;
    F(glGetProgramiv)(real_program, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetProgramInfoLog)(real_program, len, NULL, info_log);
    
    inspect_act_set_prog_info_log(&inspect_command->state, fake, info_log);
    
    free(info_log);

glValidateProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    
    real(real_program);
    
    GLint status;
    F(glGetProgramiv)(real_program, GL_LINK_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Program validation failed.");
    
    GLint len;
    F(glGetProgramiv)(real_program, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetProgramInfoLog)(real_program, len, NULL, info_log);
    
    inspect_act_set_prog_info_log(&inspect_command->state, fake, info_log);
    
    free(info_log);

glUseProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program && fake) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    
    real(real_program);

glIsBuffer:
    ;

glIsProgram:
    ;

glIsQuery:
    ;

glIsShader:
    ;

glIsTexture:
    ;

glIsVertexArray:
    ;

glIsProgramPipeline:
    ;

glIsRenderbuffer:
    ;

glIsSampler:
    ;

glIsSync:
    ;

glIsTransformFeedback:
    ;

glBindAttribLocation:
    GLuint fake_prog = gl_param_GLuint(command, 0);
    GLuint index = gl_param_GLuint(command, 1);
    const GLchar* name = gl_param_string(command, 2);
    
    GLuint program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_prog);
    if (!program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    
    real(program, index, name);

glGetAttribLocation:
    GLuint fake = gl_param_GLuint(command, 0);
    const GLchar* name = gl_param_string(command, 1);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    if (real(real_program, name) < 0)
        inspect_add_error(inspect_command, "No such attribute \"%s\".", name);

glGetUniformLocation:
    GLuint fake = gl_param_GLuint(command, 0);
    const GLchar* name = gl_param_string(command, 1);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    if (real(real_program, name) < 0)
        inspect_add_error(inspect_command, "No such uniform \"%s\".", name);

glGetShaderiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr)
        inspect_add_error(inspect_command, "Invalid shader.");

glGetShaderInfoLog:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr)
        inspect_add_error(inspect_command, "Invalid shader.");

glGetShaderSource:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr)
        inspect_add_error(inspect_command, "Invalid shader.");

glGetQueryiv:
    ;

glGetQueryObjectiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_query = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake);
    if (!real_query)
        inspect_add_error(inspect_command, "Invalid query.");

glGetQueryObjectuiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_query = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake);
    if (!real_query)
        inspect_add_error(inspect_command, "Invalid query.");

glGetProgramInfoLog:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_prog = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_prog)
        inspect_add_error(inspect_command, "Invalid program.");

glGetProgramiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_prog = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_prog)
        inspect_add_error(inspect_command, "Invalid program.");

glGetTexLevelParameterfv:
    ;

glGetTexLevelParameteriv:
    ;

glGetTexParameterfv:
    ;

glGetTexParameteriv:
    ;

glGetPointerv:
    ;

glGetPolygonStipple:
    ;

glGetMinmax:
    ;

glGetMinmaxParameterfv:
    ;

glGetMinmaxParameteriv:
    ;

glGetPixelMapfv:
    ;

glGetPixelMapuiv:
    ;

glGetPixelMapusv:
    ;

glGetSeparableFilter:
    ;

glGetBufferParameteriv:
    ;

glGetBufferPointerv:
    ;

glGetBufferSubData:
    ;

glGetTexImage:
    ;

glGetBooleanv:
    ;

glGetDoublev:
    ;

glGetFloatv:
    ;

glGetIntegerv:
    ;

glGetString:
    ;

glGetStringi:
    ;

glGetVertexAttribdv:
    ;

glGetVertexAttrivfv:
    ;

glGetVertexAttribiv:
    ;

glGetVertexAttribPointerv:
    ;

glGetCompressedTexImage:
    ;

glGetAttachedShaders:
    ;

glGetActiveUniform:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glGetActiveAttrib:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glGetBooleanv:
    ;

glGetDoublev:
    ;

glGetFloatv:
    ;

glGetIntegerv:
    ;

glGetInteger64v:
    ;

glGetBooleani_v:
    ;

glGetIntegeri_v:
    ;

glGetFloati_v:
    ;

glGetDouble_v:
    ;

glGetInteger64i_v:
    ;

glReadPixels:
    ;

glGetSamplerParamaterfv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!real_sampler)
        inspect_add_error(inspect_command, "Invalid sampler.");

glGetSamplerParamateriv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!real_sampler)
        inspect_add_error(inspect_command, "Invalid sampler.");

glGetSamplerParamaterIiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!real_sampler)
        inspect_add_error(inspect_command, "Invalid sampler.");

glGetSamplerParamaterIuiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!real_sampler)
        inspect_add_error(inspect_command, "Invalid sampler.");

glProgramUniformWIP15:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    
    GLint loc = F(glGetUniformLocation)(real_program, gl_param_string(command, 1));
    if (loc < 0) {
        inspect_add_error(inspect_command, "Nonexistent or inactive uniform.");
        RETURN;
    }
    
    replay_add_uniform(ctx, fake, gl_param_GLuint(command, 2), loc);

glUniform1f:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc, gl_param_GLfloat(command, 1));

glUniform2f:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc, gl_param_GLfloat(command, 1), gl_param_GLfloat(command, 2));

glUniform3f:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc,
         gl_param_GLfloat(command, 1),
         gl_param_GLfloat(command, 2),
         gl_param_GLfloat(command, 3));

glUniform4f:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc,
         gl_param_GLfloat(command, 1),
         gl_param_GLfloat(command, 2),
         gl_param_GLfloat(command, 3),
         gl_param_GLfloat(command, 4));

glUniform1i:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc, gl_param_GLint(command, 1));

glUniform2i:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc, gl_param_GLint(command, 1), gl_param_GLint(command, 2));

glUniform3i:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc,
         gl_param_GLint(command, 1),
         gl_param_GLint(command, 2),
         gl_param_GLint(command, 3));

glUniform4i:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc,
         gl_param_GLint(command, 1),
         gl_param_GLint(command, 2),
         gl_param_GLint(command, 3),
         gl_param_GLint(command, 4));

glUniform1ui:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc, gl_param_GLuint(command, 1));

glUniform2ui:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc, gl_param_GLuint(command, 1), gl_param_GLuint(command, 2));

glUniform3ui:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc,
         gl_param_GLuint(command, 1),
         gl_param_GLuint(command, 2),
         gl_param_GLuint(command, 3));

glUniform4ui:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    real(loc,
         gl_param_GLuint(command, 1),
         gl_param_GLuint(command, 2),
         gl_param_GLuint(command, 3),
         gl_param_GLuint(command, 4));

glUniform1fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform2fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0; i < count*2; i++)
        values[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform3fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0; i < count*3; i++)
        values[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform4fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0; i < count*4; i++)
        values[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform1iv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLint values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_int(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform2iv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLint values[count];
    for (GLsizei i = 0 ; i < count*2; i++)
        values[i] = trace_get_int(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform3iv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLint values[count];
    for (GLsizei i = 0 ; i < count*3; i++)
        values[i] = trace_get_int(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform4iv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLint values[count];
    for (GLsizei i = 0 ; i < count*4; i++)
        values[i] = trace_get_int(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform1uiv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLuint values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_uint(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform2uiv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLuint values[count];
    for (GLsizei i = 0 ; i < count*2; i++)
        values[i] = trace_get_uint(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform3uiv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLuint values[count];
    for (GLsizei i = 0 ; i < count*3; i++)
        values[i] = trace_get_uint(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform4uiv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLuint values[count];
    for (GLsizei i = 0 ; i < count*4; i++)
        values[i] = trace_get_uint(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniformMatrix2fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count*4];
    for (GLsizei i = 0 ; i < count*4; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix3fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count*9];
    for (GLsizei i = 0 ; i < count*9; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix4fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count*16];
    for (GLsizei i = 0 ; i < count*16; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix2x3fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count*6];
    for (GLsizei i = 0 ; i < count*6; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix3x2fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count*6];
    for (GLsizei i = 0 ; i < count*6; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix2x4fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count*8];
    for (GLsizei i = 0 ; i < count*8; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix4x2fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count*8];
    for (GLsizei i = 0 ; i < count*8; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix3x4fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count*12];
    for (GLsizei i = 0 ; i < count*12; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix4x3fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        RETURN;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count*12];
    for (GLsizei i = 0 ; i < count*12; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glProgramAttribWIP15:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    
    GLint loc = F(glGetAttribLocation)(real_program, gl_param_string(command, 1));
    if (loc < 0) {
        inspect_add_error(inspect_command, "Nonexistent or inactive uniform.");
        RETURN;
    }
    
    replay_add_attrib(ctx, fake, gl_param_GLuint(command, 2), loc);

glVertexAttribPointer:
    real(gl_param_GLint(command, 0),
         gl_param_GLint(command, 1),
         gl_param_GLenum(command, 2),
         gl_param_GLboolean(command, 3),
         gl_param_GLsizei(command, 4),
         (const GLvoid*)gl_param_pointer(command, 5));
    update_vao(ctx, inspect_command);

glEnableVertexAttribArray:
    real(gl_param_GLint(command, 0));
    update_vao(ctx, inspect_command);

glDisableVertexAttribArray:
    real(gl_param_GLint(command, 0));
    update_vao(ctx, inspect_command);

glDrawArrays:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLint first = gl_param_GLint(command, 1);
    GLsizei count = gl_param_GLsizei(command, 2);
    
    real(mode, first, count);
    
    end_draw(ctx, inspect_command);

glDrawArraysInstanced:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLint first = gl_param_GLint(command, 1);
    GLsizei count = gl_param_GLsizei(command, 2);
    GLsizei primcount = gl_param_GLsizei(command, 3);
    
    real(mode, first, count, primcount);
    
    end_draw(ctx, inspect_command);

glMultiDrawArrays:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    int64_t* first64 = trace_get_int(trace_get_arg(command, 1));
    int64_t* count64 = trace_get_int(trace_get_arg(command, 2));
    GLsizei primcount = gl_param_GLsizei(command, 3);
    
    GLint first[primcount];
    GLint count[primcount];
    for (GLsizei i = 0; i < primcount; i++) {
        first[i] = first64[i];
        count[i] = count64[i];
    }
    
    real(mode, first, count, primcount);
    
    end_draw(ctx, inspect_command);

glMultiDrawElements:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    int64_t* count64 = trace_get_int(trace_get_arg(command, 1));
    GLenum type = gl_param_GLenum(command, 2);
    uint64_t* indicesi = trace_get_ptr(trace_get_arg(command, 3));
    GLsizei drawcount = gl_param_GLsizei(command, 4);
    
    GLint count[drawcount];
    const GLvoid* indices[drawcount];
    for (GLsizei i = 0; i < drawcount; i++) {
        count[i] = count64[i];
        indices[i] = (const GLvoid*)indicesi[i];
    }
    
    real(mode, count, type, indices, drawcount);
    
    end_draw(ctx, inspect_command);

glMultiDrawElementsBaseVertex:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    int64_t* count64 = trace_get_int(trace_get_arg(command, 1));
    GLenum type = gl_param_GLenum(command, 2);
    uint64_t* indicesi = trace_get_ptr(trace_get_arg(command, 3));
    GLsizei drawcount = gl_param_GLsizei(command, 4);
    int64_t* basevertex64 = trace_get_int(trace_get_arg(command, 5));
    
    GLint count[drawcount];
    const GLvoid* indices[drawcount];
    GLint basevertex[drawcount];
    for (GLsizei i = 0; i < drawcount; i++) {
        count[i] = count64[i];
        indices[i] = (const GLvoid*)indicesi[i];
        basevertex[i] = basevertex64[i];
    }
    
    real(mode, count, type, indices, drawcount, basevertex);
    
    end_draw(ctx, inspect_command);

glDrawElements:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLsizei count = gl_param_GLsizei(command, 1);
    GLenum type = gl_param_GLenum(command, 2);
    const GLvoid* indices = (const GLvoid*)gl_param_pointer(command, 3);
    
    real(mode, count, type, indices);
    
    end_draw(ctx, inspect_command);

glDrawElementsBaseVertex:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLsizei count = gl_param_GLsizei(command, 1);
    GLenum type = gl_param_GLenum(command, 2);
    const GLvoid* indices = (const GLvoid*)gl_param_pointer(command, 3);
    GLint basevertex = gl_param_GLint(command, 4);
    
    real(mode, count, type, indices, basevertex);
    
    end_draw(ctx, inspect_command);

glDrawElementsInstanced:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLsizei count = gl_param_GLsizei(command, 1);
    GLenum type = gl_param_GLenum(command, 2);
    const GLvoid* indices = (const GLvoid*)gl_param_pointer(command, 3);
    GLsizei primcount = gl_param_GLsizei(command, 4);
    
    real(mode, count, type, indices, primcount);
    
    end_draw(ctx, inspect_command);

glDrawElementsInstancedBaseVertex:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLsizei count = gl_param_GLsizei(command, 1);
    GLenum type = gl_param_GLenum(command, 2);
    const GLvoid* indices = (const GLvoid*)gl_param_pointer(command, 3);
    GLsizei primcount = gl_param_GLsizei(command, 4);
    GLint basevertex = gl_param_GLint(command, 4);
    
    real(mode, count, type, indices, primcount, basevertex);
    
    end_draw(ctx, inspect_command);

glDrawRangeElements:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLuint start = gl_param_GLuint(command, 1);
    GLuint end = gl_param_GLuint(command, 2);
    GLsizei count = gl_param_GLsizei(command, 3);
    GLenum type = gl_param_GLenum(command, 4);
    const GLvoid* indices = (const GLvoid*)gl_param_pointer(command, 5);
    
    real(mode, start, end, count, type, indices);
    
    end_draw(ctx, inspect_command);

glDrawRangeElementsBaseVertex:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLuint start = gl_param_GLuint(command, 1);
    GLuint end = gl_param_GLuint(command, 2);
    GLsizei count = gl_param_GLsizei(command, 3);
    GLenum type = gl_param_GLenum(command, 4);
    const GLvoid* indices = (const GLvoid*)gl_param_pointer(command, 5);
    GLint basevertex = gl_param_GLint(command, 6);
    
    real(mode, start, end, count, type, indices, basevertex);
    
    end_draw(ctx, inspect_command);

glTestFBWIP15:
    F(glFinish)();
    
    GLint last_buf;
    F(glGetIntegerv)(GL_READ_BUFFER, &last_buf);
    
    F(glReadBuffer)(GL_BACK);
    uint32_t* back = malloc(100*100*4);
    F(glReadPixels)(0, 0, 100, 100, GL_RGBA, GL_UNSIGNED_BYTE, back);
    
    uint32_t* depth = malloc(100*100*4);
    F(glReadPixels)(0, 0, 100, 100, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, depth);
    
    F(glReadBuffer)(last_buf);
    
    if (memcmp(back, gl_param_data(command, 1), 100*100*4) != 0)
        fprintf(stderr, "%s did not result in the correct back color buffer (test: %s).\n", gl_param_string(command, 0), ctx->current_test_name);
    
    //TODO
    /*for (int32_t i = 0; i < 100*100; i++)
        if ((int64_t)depth[i] - (int64_t)((int32_t*)gl_param_data(command, 2))[i] > 16843009) {
            fprintf(stderr, "%s did not result in the correct depth buffer (test: %s).\n", gl_param_string(command, 0), ctx->current_test_name);
            break;
        }*/
    
    free(back);
    free(depth);

glCurrentTestWIP15:
    ctx->current_test_name = gl_param_string(command, 0);

glGenVertexArrays:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint arrays[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, arrays);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLVAO, arrays[i], fake[i]);
        inspect_act_gen_vao(&inspect_command->state, fake[i]);
    }

glDeleteVertexArrays:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint arrays[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i)
        if (!(arrays[i] = replay_get_real_object(ctx, ReplayObjType_GLVAO, fake[i]))) {
            inspect_add_error(inspect_command, "Invalid vertex array being deleted.");
        } else {
            inspect_act_del_vao(&inspect_command->state, fake[i]);
            replay_destroy_object(ctx, ReplayObjType_GLVAO, fake[i]);
        }
    
    real(n, arrays);

glBindVertexArray:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_vao = replay_get_real_object(ctx, ReplayObjType_GLVAO, fake);
    if (!real_vao && fake)
        inspect_add_error(inspect_command, "Invalid vertex array being bound.");
    real(real_vao);

glPatchParameterfv:
    GLenum pname = gl_param_GLenum(command, 0);
    GLfloat values[trace_get_arg(command, 1)->count];
    for (size_t i = 0; i < trace_get_arg(command, 1)->count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 1))[i];
    real(pname, values);

glGetFragDataIndex:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glGetFragDataLocation:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glDrawableSizeWIP15:
    GLsizei w = gl_param_GLsizei(command, 0);
    GLsizei h = gl_param_GLsizei(command, 1);
    
    if (w < 0)
        w = 100;
    if (h < 0)
        h = 100;
    
    SDL_SetWindowSize(ctx->window, w, h);
    
    //TODO: This is a hack
    F(glViewport)(0, 0, w, h);

glGetUniformfv:
    get_uniform(ctx, inspect_command, command);

glGetUniformiv:
    get_uniform(ctx, inspect_command, command);

glGetUniformuiv:
    get_uniform(ctx, inspect_command, command);

glGetUniformdv:
    get_uniform(ctx, inspect_command, command);

glGetnUniformfv:
    get_uniform(ctx, inspect_command, command);

glGetnUniformiv:
    get_uniform(ctx, inspect_command, command);

glGetnUniformuiv:
    get_uniform(ctx, inspect_command, command);

glGetnUniformdv:
    get_uniform(ctx, inspect_command, command);

glGetMultisamplefv:
    ;

glGetInternalFormativ:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum internalformat = gl_param_GLenum(command, 1);
    GLenum pname = gl_param_Glenum(command, 2);
    GLsizei bufSize = gl_param_GLsizei(command, 3);
    GLubyte params[bufSize];
    real(target, internalformat, pname, bufSize, params);

glGetInternalFormati64v:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum internalformat = gl_param_GLenum(command, 1);
    GLenum pname = gl_param_Glenum(command, 2);
    GLsizei bufSize = gl_param_GLsizei(command, 3);
    GLubyte params[bufSize];
    real(target, internalformat, pname, bufSize, params);

glGetBufferParameteriv:
    GLint i;
    real(gl_param_GLenum(command, 0), gl_param_GLenum(command, 1), &i);

glGetBufferPointerv:
    GLvoid* p;
    real(gl_param_GLenum(command, 1), gl_param_GLenum(command, 1), &p);

glGenSamplers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint samplers[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, samplers);
    
    for (size_t i = 0; i < n; ++i)
        replay_create_object(ctx, ReplayObjType_GLSampler, samplers[i], fake[i]);

glDeleteSamplers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint samplers[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i)
        if (!(samplers[i] = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake[i])))
            inspect_add_error(inspect_command, "Invalid sampler being deleted.");
        else
            replay_destroy_object(ctx, ReplayObjType_GLSampler, fake[i]);
    
    real(n, samplers);

glBindSampler:
    GLuint unit = gl_param_GLuint(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint real_tex = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!real_tex && fake) {
        inspect_add_error(inspect_command, "Invalid sampler being bound.");
        RETURN;
    }
    real(unit, real_tex);

glPointParameterfv:
    F(glPointParameterf)(gl_param_GLenum(command, 0), gl_param_GLfloat(command, 1));

glPointParameteriv:
    F(glPointParameteri)(gl_param_GLenum(command, 0), gl_param_GLint(command, 1));

glGetSynciv:
    uint64_t fake = gl_param_GLsync(command, 0);
    GLsync sync = (GLsync)replay_get_real_object(ctx, ReplayObjType_GLSync, fake);
    if (!sync)
        inspect_add_error(inspect_command, "Invalid sync object.");

glSamplerParameterf:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!sampler) {
        inspect_add_error(inspect_command, "Invalid sampler.");
        RETURN;
    }
    GLenum pname = gl_param_GLenum(command, 1);
    GLfloat param = gl_param_GLfloat(command, 2);
    real(sampler, pname, param);

glSamplerParameteri:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!sampler) {
        inspect_add_error(inspect_command, "Invalid sampler.");
        RETURN;
    }
    GLenum pname = gl_param_GLenum(command, 1);
    GLint param = gl_param_GLint(command, 2);
    real(sampler, pname, param);

glSamplerParameterfv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!sampler) {
        inspect_add_error(inspect_command, "Invalid sampler.");
        RETURN;
    }
    GLenum pname = gl_param_GLenum(command, 1);
    double* paramsd = trace_get_double(trace_get_arg(command, 2));
    
    GLfloat params[4];
    if (pname == GL_TEXTURE_BORDER_COLOR)
        for (size_t i = 0; i < 4; i++)
            params[i] = paramsd[i];
    else
        params[0] = paramsd[0];
    
    real(sampler, pname, params);

glSamplerParameteriv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!sampler) {
        inspect_add_error(inspect_command, "Invalid sampler.");
        RETURN;
    }
    GLenum pname = gl_param_GLenum(command, 1);
    int64_t* params64 = trace_get_int(trace_get_arg(command, 2));
    
    GLint params[4];
    if (pname == GL_TEXTURE_BORDER_COLOR)
        for (size_t i = 0; i < 4; i++)
            params[i] = params64[i];
    else
        params[0] = params64[0];
    
    real(sampler, pname, params);

glSamplerParameterIiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!sampler) {
        inspect_add_error(inspect_command, "Invalid sampler.");
        RETURN;
    }
    GLenum pname = gl_param_GLenum(command, 1);
    int64_t* params64 = trace_get_int(trace_get_arg(command, 2));
    
    GLint params[4];
    if (pname == GL_TEXTURE_BORDER_COLOR)
        for (size_t i = 0; i < 4; i++)
            params[i] = params64[i];
    else
        params[0] = params64[0];
    
    real(sampler, pname, params);

glSamplerParameterIuiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint sampler = replay_get_real_object(ctx, ReplayObjType_GLSampler, fake);
    if (!sampler) {
        inspect_add_error(inspect_command, "Invalid sampler.");
        RETURN;
    }
    GLenum pname = gl_param_GLenum(command, 1);
    uint64_t* params64 = trace_get_uint(trace_get_arg(command, 2));
    
    GLuint params[4];
    if (pname == GL_TEXTURE_BORDER_COLOR)
        for (size_t i = 0; i < 4; i++)
            params[i] = params64[i];
    else
        params[0] = params64[0];
    
    real(sampler, pname, params);

glGenFramebuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint fbs[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, fbs);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLFramebuffer, fbs[i], fake[i]);
        inspect_act_gen_fb(&inspect_command->state, fake[i]);
    }

glDeleteFramebuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint fbs[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i)
        if (!(fbs[i] = replay_get_real_object(ctx, ReplayObjType_GLFramebuffer, fake[i]))) {
            inspect_add_error(inspect_command, "Invalid framebuffer being deleted.");
        } else {
            inspect_act_del_fb(&inspect_command->state, fake[i]);
            replay_destroy_object(ctx, ReplayObjType_GLFramebuffer, fake[i]);
        }
    
    real(n, fbs);

glBindFramebuffer:
    GLenum target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint fb = replay_get_real_object(ctx, ReplayObjType_GLFramebuffer, fake);
    if (!fb && fake) {
        inspect_add_error(inspect_command, "Invalid framebuffer being bound.");
        RETURN;
    }
    real(target, fb);

glGenRenderbuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint rbs[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, rbs);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLRenderbuffer, rbs[i], fake[i]);
        inspect_act_gen_rb(&inspect_command->state, fake[i]);
    }

glBindRenderbuffer:
    GLenum target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint rb = replay_get_real_object(ctx, ReplayObjType_GLRenderbuffer, fake);
    if (!rb && fake) {
        inspect_add_error(inspect_command, "Invalid renderbuffer being bound.");
        RETURN;
    }
    real(target, rb);

glDeleteRenderbuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint rbs[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i)
        if (!(rbs[i] = replay_get_real_object(ctx, ReplayObjType_GLRenderbuffer, fake[i]))) {
            inspect_add_error(inspect_command, "Invalid renderbuffer being deleted.");
        } else {
            inspect_act_del_rb(&inspect_command->state, fake[i]);
            replay_destroy_object(ctx, ReplayObjType_GLRenderbuffer, fake[i]);
        }
    
    real(n, rbs);

glGetActiveUniformBlockiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    GLuint uniformBlockIndex = gl_param_GLuint(command, 1);
    GLenum pname = gl_param_GLenum(command, 2);
    
    if (pname == GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES) {
        GLint count;
        real(program, uniformBlockIndex,GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS, &count);
        
        GLint* vals = malloc(sizeof(GLint)*count);
        real(program, uniformBlockIndex, pname, vals);
        free(vals);
    } else {
        GLint v;
        real(program, uniformBlockIndex, pname, &v);
    }

glGetActiveUniformBlockName:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    GLuint uniformBlockIndex = gl_param_GLuint(command, 1);
    GLchar buf[64];
    real(program, uniformBlockIndex, 64, NULL, buf);

glGetActiveUniformName:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    GLuint uniformIndex = gl_param_GLuint(command, 1);
    GLchar buf[64];
    real(program, uniformIndex, 64, NULL, buf);

glGetActiveUniformsiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!program) {
        inspect_add_error(inspect_command, "Invalid program.");
        RETURN;
    }
    GLsizei uniformCount = gl_param_GLsizei(command, 1);
    uint64_t* uniformIndices64 = trace_get_uint(trace_get_arg(command, 2));
    GLenum pname = gl_param_GLenum(command, 3);
    
    GLuint* uniformIndices = malloc(uniformCount*sizeof(GLuint));
    for (GLsizei i = 0; i < uniformCount; i++)
        uniformIndices[i] = uniformIndices64[i];
    
    GLint* params = malloc(uniformCount*sizeof(GLint));
    
    real(program, uniformCount, uniformIndices, pname, params);
    
    free(params);
    free(uniformIndices);

glGetFramebufferAttachmentParameteriv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum attachment = gl_param_GLenum(command, 1);
    GLenum pname = gl_param_GLenum(command, 2);
    GLint params;
    real(target, attachment, pname, &params);

glGetRenderbufferParameteriv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    GLint params;
    real(target, pname, &params);

glFramebufferRenderbuffer:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum attachment = gl_param_GLenum(command, 1);
    GLenum renderbuffertarget = gl_param_GLenum(command, 2);
    GLuint renderbuffer = gl_param_GLuint(command, 3);
    
    GLuint real_rb = replay_get_real_object(ctx, ReplayObjType_GLRenderbuffer, renderbuffer);
    if (!real_rb && renderbuffer) {
        inspect_add_error(inspect_command, "Invalid renderbuffer.");
        RETURN;
    }
    
    real(target, attachment, renderbuffertarget, real_rb);
    
    GLint fb = get_bound_framebuffer(ctx, target);
    if (!fb) {
        inspect_add_error(inspect_command, "No or invalid framebuffer bound.");
        RETURN;
    }
    
    framebuffer_attachment(inspect_command, ctx, fb, attachment, 0, 0);

glFramebufferTexture:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum attachment = gl_param_GLenum(command, 1);
    GLuint texture = gl_param_GLuint(command, 2);
    GLint level = gl_param_GLint(command, 3);
    
    GLuint real_tex = replay_get_real_object(ctx, ReplayObjType_GLTexture, texture);
    if (!real_tex && texture) {
        inspect_add_error(inspect_command, "Invalid texture.");
        RETURN;
    }
    
    real(target, attachment, real_tex, level);
    
    GLint fb = get_bound_framebuffer(ctx, target);
    if (!fb) {
        inspect_add_error(inspect_command, "No or invalid framebuffer bound.");
        RETURN;
    }
    
    framebuffer_attachment(inspect_command, ctx, fb, attachment, texture, level);

glFramebufferTexture2D:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum attachment = gl_param_GLenum(command, 1);
    GLenum textarget = gl_param_GLenum(command, 2);
    GLuint texture = gl_param_GLuint(command, 3);
    GLint level = gl_param_GLint(command, 4);
    
    GLuint real_tex = replay_get_real_object(ctx, ReplayObjType_GLTexture, texture);
    if (!real_tex && texture) {
        inspect_add_error(inspect_command, "Invalid texture.");
        RETURN;
    }
    
    real(target, attachment, textarget, real_tex, level);
    
    GLint fb = get_bound_framebuffer(ctx, target);
    if (!fb) {
        inspect_add_error(inspect_command, "No or invalid framebuffer bound.");
        RETURN;
    }
    
    framebuffer_attachment(inspect_command, ctx, fb, attachment, texture, level);

glRenderbufferStorage:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum internalformat = gl_param_GLenum(command, 1);
    GLsizei width = gl_param_GLsizei(command, 2);
    GLsizei height = gl_param_GLsizei(command, 3);
    real(target, internalformat, width, height);
    update_renderbuffer(ctx, inspect_command);

glRenderbufferStorageMultisample:
    GLenum target = gl_param_GLenum(command, 0);
    GLsizei samples = gl_param_GLsizei(command, 1);
    GLenum internalformat = gl_param_GLenum(command, 2);
    GLsizei width = gl_param_GLsizei(command, 3);
    GLsizei height = gl_param_GLsizei(command, 4);
    real(target, samples, internalformat, width, height);
    update_renderbuffer(ctx, inspect_command);

glFenceSync:
    GLenum condition = gl_param_GLenum(command, 0);
    GLbitfield flags = gl_param_GLbitfield(command, 1);
    GLsync real_sync = real(condition, flags);
    
    uint64_t fake = *trace_get_ptr(&command->ret);
    
    replay_create_object(ctx, ReplayObjType_GLSync, (uint64_t)real_sync, fake);
    inspect_act_gen_sync(&inspect_command->state, fake);
    
    inspect_sync_t sync;
    sync.fake = fake;
    sync.type = GL_SYNC_FENCE;
    sync.condition = condition;
    sync.flags = flags;
    
    inspect_act_set_sync(&inspect_command->state, &sync);

glDeleteSync:
    uint64_t fake = gl_param_GLsync(command, 0);
    uint64_t real_sync = replay_get_real_object(ctx, ReplayObjType_GLSync, fake);
    if (!real_sync && fake) {
        inspect_add_error(inspect_command, "Invalid sync object.");
        RETURN;
    }
    
    real((GLsync)real_sync);
    
    if (fake) {
        replay_destroy_object(ctx, ReplayObjType_GLSync, fake);
        inspect_act_del_sync(&inspect_command->state, fake);
    }

glWaitSync:
    uint64_t fake = gl_param_GLsync(command, 0);
    uint64_t real_sync = replay_get_real_object(ctx, ReplayObjType_GLSync, fake);
    if (!real_sync) {
        inspect_add_error(inspect_command, "Invalid sync object.");
        RETURN;
    }
    
    real((GLsync)real_sync, gl_param_GLbitfield(command, 1), gl_param_GLuint64(command, 2));

glClientWaitSync:
    uint64_t fake = gl_param_GLsync(command, 0);
    uint64_t real_sync = replay_get_real_object(ctx, ReplayObjType_GLSync, fake);
    if (!real_sync) {
        inspect_add_error(inspect_command, "Invalid sync object.");
        RETURN;
    }
    
    real((GLsync)real_sync, gl_param_GLbitfield(command, 1), gl_param_GLuint64(command, 2));

glGenQueries:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint queries[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, queries);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLQuery, queries[i], fake[i]);
        inspect_act_gen_query(&inspect_command->state, fake[i]);
    }

glDeleteQueries:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint queries[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i)
        if (!(queries[i] = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake[i]))) {
            inspect_add_error(inspect_command, "Invalid query being deleted.");
        } else {
            replay_destroy_object(ctx, ReplayObjType_GLQuery, fake[i]);
            inspect_act_del_query(&inspect_command->state, fake[i]);
        }
    
    real(n, queries);

glBeginQuery:
    GLuint id = gl_param_GLuint(command, 1);
    GLuint real_id = replay_get_real_object(ctx, ReplayObjType_GLQuery, id);
    if (!real_id) {
        inspect_add_error(inspect_command, "Invalid query object.");
        RETURN;
    }
    
    GLenum target = gl_param_GLenum(command, 0);
    
    real(target, real_id);
    
    update_query_type(ctx, inspect_command, target);

glEndQuery:
    GLenum target = gl_param_GLenum(command, 0);
    GLint id;
    F(glGetQueryiv)(target, GL_CURRENT_QUERY, &id);
    real(target);
    //TODO: This clears any errors
    if (F(glGetError)() == GL_NO_ERROR)
        update_query(ctx, inspect_command, target, id);

glQueryCounter:
    GLuint id = gl_param_GLuint(command, 0);
    GLuint real_id = replay_get_real_object(ctx, ReplayObjType_GLQuery, id);
    if (!real_id) {
        inspect_add_error(inspect_command, "Invalid query object.");
        RETURN;

    }
    GLenum target = gl_param_GLenum(command, 1);
    real(real_id, target);
    //TODO: This clears any errors
    if (F(glGetError)() == GL_NO_ERROR)
        update_query(ctx, inspect_command, target, real_id);

glDrawBuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    
    GLuint* bufs = malloc(sizeof(GLuint)*n);
    for (GLsizei i = 0; i < n; i++)
        bufs[i] = trace_get_uint(trace_get_arg(command, 1))[i];
    
    real(n, bufs);
    free(bufs);

glClearBufferiv:
    GLenum buffer = gl_param_GLenum(command, 0);
    GLint drawbuffer = gl_param_GLint(command, 1);
    size_t count = buffer == GL_COLOR ? 4 : 1;
    GLint value[count];
    for (size_t i = 0; i < count; i++)
        value[i] = trace_get_int(trace_get_arg(command, 2))[i];
    
    real(buffer, drawbuffer, value);
    
    update_drawbuffer(ctx, inspect_command, buffer, drawbuffer);

glClearBufferuiv:
    GLenum buffer = gl_param_GLenum(command, 0);
    GLint drawbuffer = gl_param_GLint(command, 1);
    size_t count = buffer == GL_COLOR ? 4 : 1;
    GLuint value[count];
    for (size_t i = 0; i < count; i++)
        value[i] = trace_get_uint(trace_get_arg(command, 2))[i];
    
    real(buffer, drawbuffer, value);
    
    update_drawbuffer(ctx, inspect_command, buffer, drawbuffer);

glClearBufferfv:
    GLenum buffer = gl_param_GLenum(command, 0);
    GLint drawbuffer = gl_param_GLint(command, 1);
    size_t count = buffer == GL_COLOR ? 4 : 1;
    GLfloat value[count];
    for (size_t i = 0; i < count; i++)
        value[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(buffer, drawbuffer, value);
    
    update_drawbuffer(ctx, inspect_command, buffer, drawbuffer);

glClearBufferfi:
    GLenum buffer = gl_param_GLenum(command, 0);
    GLint drawbuffer = gl_param_GLint(command, 1);
    GLfloat depth = gl_param_GLfloat(command, 2);
    GLint stencil = gl_param_GLint(command, 3);
    real(buffer, drawbuffer, depth, stencil);
    
    update_drawbuffer(ctx, inspect_command, GL_DEPTH, 0);
    update_drawbuffer(ctx, inspect_command, GL_STENCIL, 0);
