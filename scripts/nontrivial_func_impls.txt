glXMakeCurrent:
    GLXContext glctx = NULL;
    uint64_t fake_ctx = *trace_get_uint(&trace_get_arg(command, 2)->val);
    if (fake_ctx) {
        glctx = (GLXContext)replay_get_real_object(ctx, ReplayObjType_GLXContext, fake_ctx);
        if (!glctx) {
            inspect_add_error(inspect_command, "Invalid GLX context.");
            return;
        }
    }
    
    if (!real(ctx->_display, glctx ? ctx->_glx_drawable : None, glctx)) {
        inspect_add_error(inspect_command, "Unable to make a context current.");
        return;
    }
    
    if (glctx) {
        reload_gl_funcs(ctx);
        ctx->_current_context = glctx;
    } else {
        reset_gl_funcs(ctx);
        ctx->_current_context = NULL;
    }
    
    if (F(glXSwapIntervalEXT))
        F(glXSwapIntervalEXT)(ctx->_display, ctx->_glx_drawable, 0);
    //TODO
    //else if (F(glXSwapIntervalMESA))
    //    F(glXSwapIntervalMESA)(0);
    else if (F(glXSwapIntervalSGI))
        F(glXSwapIntervalSGI)(0);

glXGetProcAddressARB:
    void (*result)() = real((const GLubyte*)gl_param_string(command, 0));
    if ((result == NULL) != (*trace_get_ptr(&command->ret) == 0))
        inspect_add_warning(inspect_command, "glXGetProcAddress returned NULL when the other did not.");

glXGetProcAddress:
    void (*result)() = real((const GLubyte*)gl_param_string(command, 0));
    if ((result == NULL) != (*trace_get_ptr(&command->ret) == 0))
        inspect_add_warning(inspect_command, "glXGetProcAddress returned NULL when the other did not.");

glXQueryExtension:
    Bool result = real(ctx->_display, NULL, NULL);
    if (result != *trace_get_bool(&command->ret))
        inspect_add_warning(inspect_command, "glXQueryExtension returned something different during replay.");

glXChooseVisual:
    trace_value_t attribs = trace_get_arg(command, 2)->val;
    int int_attribs[attribs.count];
    for (size_t i = 0; i < attribs.count; ++i) {
        union {unsigned int u; int i;} u;
        u.u = trace_get_uint(&attribs)[i];
        int_attribs[i] = u.i;
    }
    XVisualInfo* vis = real(ctx->_display, gl_param_int(command, 1), int_attribs);
    if (!vis) {
        inspect_add_error(inspect_command, "Unable to create visual.");
        return;
    }
    XFree(vis);

glXCreateContext:
    GLXContext shareList = NULL;
    if (*trace_get_ptr(&trace_get_arg(command, 2)->val)) {
        shareList = (GLXContext)replay_get_real_object(ctx,
                                                       ReplayObjType_GLXContext,
                                                       *trace_get_ptr(&trace_get_arg(command, 2)->val));
        if (!shareList) {
            inspect_add_error(inspect_command, "Invalid share list.");
            return;
        }
    }
    GLXContext res = F(glXCreateNewContext)(ctx->_display, ctx->_fbconfig, GLX_RGBA_TYPE, shareList, gl_param_Bool(command, 3));
    replay_create_object(ctx, ReplayObjType_GLXContext, (uint64_t)res, *trace_get_ptr(&command->ret));

glXQueryExtensionsString:
    ;

glXDestroyContext:
    GLXContext glctx = (GLXContext)replay_get_real_object(ctx,
                                                          ReplayObjType_GLXContext,
                                                          *trace_get_ptr(&trace_get_arg(command, 1)->val));
    if (!glctx) {
        inspect_add_error(inspect_command, "Invalid GLX context.");
        return;
    }
    
    real(ctx->_display, glctx);
    replay_destroy_object(ctx, ReplayObjType_GLXContext, *trace_get_ptr(&trace_get_arg(command, 1)->val));

glXSwapBuffers:
    if (!ctx->_current_context) {
        inspect_add_error(inspect_command, "No current OpenGL context.");
        return;
    }
    real(ctx->_display, ctx->_glx_drawable);
    replay_get_back_color(ctx, inspect_command);
    replay_get_front_color(ctx, inspect_command);

glBegin:
    real(gl_param_GLenum(command, 0));
    ctx->_in_begin_end = true;

glEnd:
    real();
    ctx->_in_begin_end = false;
    replay_get_back_color(ctx, inspect_command);
    replay_get_front_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glClear:
    GLbitfield mask = gl_param_GLbitfield(command, 0);
    real(mask);
    if (mask & GL_COLOR_BUFFER_BIT)
        replay_get_back_color(ctx, inspect_command);
    if (mask & GL_DEPTH_BUFFER_BIT)
        replay_get_depth(ctx, inspect_command);

glDrawArrays:
    GLenum mode = gl_param_GLenum(command, 0);
    GLint first = gl_param_GLint(command, 1);
    GLsizei count = gl_param_GLsizei(command, 2);
    real(mode, first, count);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glGenTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    real(n, textures);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLTexture, textures[i], fake[i]);
        
        inspect_action_t action;
        action.type = InspectAction_GenTexture;
        action.texture = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }

glDeleteTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; ++i) {
        if (!(textures[i] = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake[i])))
            inspect_add_error(inspect_command, "Invalid texture being deleted.");
        
        inspect_action_t action;
        action.type = InspectAction_DelTexture;
        action.texture = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }
    
    real(n, textures);

glBindTexture:
    GLuint target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint real_tex = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake);
    if (!real_tex)
        inspect_add_error(inspect_command, "Invalid texture being bound.");
    real(target, real_tex);

glTexImage2D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint internalFormat = gl_param_GLint(command, 2);
    GLsizei width = gl_param_GLenum(command, 3);
    GLsizei height = gl_param_GLenum(command, 4);
    GLint border = gl_param_GLenum(command, 5);
    GLenum format = gl_param_GLenum(command, 6);
    GLenum type = gl_param_GLenum(command, 7);
    const void* data = gl_param_data(command, 8);
    real(target, level, internalFormat, width, height, border, format, type, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexParameterf:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    GLfloat param = gl_param_GLfloat(command, 2);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameteri:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    GLint param = gl_param_GLint(command, 2);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glGenBuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    real(n, buffers);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLBuffer, buffers[i], fake[i]);
        
        inspect_action_t action;
        action.type = InspectAction_GenBuffer;
        action.buffer = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }

glDeleteBuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; ++i) {
        if (!(buffers[i] = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake[i])))
            inspect_add_error(inspect_command, "Invalid buffer being deleted.");
        
        inspect_action_t action;
        action.type = InspectAction_DelBuffer;
        action.buffer = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }
    
    real(n, buffers);

glBindBuffer:
    GLuint target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint real_buf = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake);
    if (!real_buf)
        inspect_add_error(inspect_command, "Invalid buffer being bound.");
    real(target, real_buf);

glBufferData:
    GLuint target = gl_param_GLenum(command, 0);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 1);
    const void* data = gl_param_data(command, 2);
    GLenum usage = gl_param_GLenum(command, 3);
    real(target, size, data, usage);
    
    inspect_action_t action;
    action.type = InspectAction_BufferData;
    action.buf_data.buffer = get_bound_buffer(ctx, target);
    action.buf_data.size = size;
    action.buf_data.data = malloc(size);
    memcpy(action.buf_data.data, data, size);
    action.buf_data.usage = usage;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glBufferSubData:
    GLuint target = gl_param_GLenum(command, 0);
    GLintptr offset = gl_param_GLintptr(command, 1);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 2);
    const void* data = gl_param_data(command, 3);
    real(target, offset, size, data);
    
    inspect_action_t action;
    action.type = InspectAction_BufferData;
    action.buf_sub_data.buffer = get_bound_buffer(ctx, target);
    action.buf_sub_data.offset = offset;
    action.buf_sub_data.size = size;
    action.buf_sub_data.data = malloc(size);
    memcpy(action.buf_sub_data.data, data, size);
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glLoadMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glLoadMatrixf:
    F(glLoadMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glLoadTransposeMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glLoadTransposeMatrixf:
    F(glLoadTransposeMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glMultMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glMultMatrixf:
    F(glMultMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glMultTransposeMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glMultTransposeMatrixf:
    F(glMultTransposeMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glCreateShader:
    GLenum type = gl_param_GLenum(command, 0);
    GLuint real_shdr = F(glCreateShader)(type);
    GLuint fake = trace_get_uint(&command->ret)[0];
    replay_create_object(ctx, ReplayObjType_GLShader, real_shdr, fake);
    
    inspect_action_t action;
    action.type = InspectAction_NewShader;
    action.new_shader.type = type;
    action.new_shader.shader = fake;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glDeleteShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    F(glDeleteShader)(real_shdr);
    
    replay_destroy_object(ctx, ReplayObjType_GLShader, fake);
    
    inspect_action_t action;
    action.type = InspectAction_DelShader;
    action.del_shader = fake;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glShaderSource:
    GLuint fake = gl_param_GLuint(command, 0);
    GLsizei count = gl_param_GLsizei(command, 1);
    char** sources = gl_param_string_array(command, 2);
    
    GLuint shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    inspect_action_t action;
    action.type = InspectAction_ShaderSource;
    action.shader_source.shader = fake;
    action.shader_source.count = count;
    action.shader_source.sources = malloc(sizeof(char*)*count);
    
    if (trace_get_arg(command, 3)->val.count == 0) {
        real(shader, 1, (const GLchar*const*)sources, NULL);
        
        for (GLsizei i = 0; i < count; i++) {
            size_t len = strlen(sources[i]);
            action.shader_source.sources[i] = malloc(len+1);
            memcpy(action.shader_source.sources[i], sources[i], len);
            action.shader_source.sources[i][len] = 0;
        }
    } else {
        uint64_t* lengths64 = trace_get_uint(&trace_get_arg(command, 3)->val);
        
        GLint lengths[count];
        for (GLsizei i = 0; i < count; i++) {
            lengths[i] = lengths64[i];
        }
        
        real(shader, count, (const GLchar*const*)sources, lengths);
        
        for (GLsizei i = 0; i < count; i++) {
            action.shader_source.sources[i] = malloc(lengths[i]+1);
            memcpy(action.shader_source.sources[i], sources[i], lengths[i]);
            action.shader_source.sources[i][lengths[i]] = 0;
        }
    }
    
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glCompileShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    real(real_shdr);
    
    GLint status;
    F(glGetShaderiv)(real_shdr, GL_COMPILE_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Unable to compile shader.");
    
    GLint len;
    F(glGetShaderiv)(real_shdr, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetShaderInfoLog)(real_shdr, len, NULL, info_log);
    
    inspect_action_t action;
    action.type = InspectAction_UpdateShdrInfoLog;
    action.info_log.obj = fake;
    action.info_log.str = info_log;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glCreateProgram:
    GLuint real_program = F(glCreateProgram)();
    GLuint fake = trace_get_uint(&command->ret)[0];
    replay_create_object(ctx, ReplayObjType_GLProgram, real_program, fake);
    
    inspect_action_t action;
    action.type = InspectAction_NewProgram;
    action.program = fake;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glDeleteProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);
    
    replay_destroy_object(ctx, ReplayObjType_GLProgram, fake);
    
    inspect_action_t action;
    action.type = InspectAction_DelProgram;
    action.program = fake;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glAttachShader:
    GLuint fake_program = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_program);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    GLuint fake_shader = gl_param_GLuint(command, 1);
    GLuint real_shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake_shader);
    if (!real_shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    real(real_program, real_shader);
    
    inspect_action_t action;
    action.type = InspectAction_AttachShader;
    action.prog_shdr.program = fake_program;
    action.prog_shdr.shader = fake_shader;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glDetachShader:
    GLuint fake_program = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_program);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    GLuint fake_shader = gl_param_GLuint(command, 1);
    GLuint real_shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake_shader);
    if (!real_shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    real(real_program, real_shader);
    
    inspect_action_t action;
    action.type = InspectAction_DetachShader;
    action.prog_shdr.program = fake_program;
    action.prog_shdr.shader = fake_shader;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glLinkProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);
    
    GLint status;
    F(glGetProgramiv)(real_program, GL_LINK_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Unable to link program.");
    
    GLint len;
    F(glGetProgramiv)(real_program, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetProgramInfoLog)(real_program, len, NULL, info_log);
    
    inspect_action_t action;
    action.type = InspectAction_UpdateProgramInfoLog;
    action.info_log.obj = fake;
    action.info_log.str = info_log;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);


glValidateProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);
    
    GLint status;
    F(glGetProgramiv)(real_program, GL_LINK_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Program validation failed.");
    
    GLint len;
    F(glGetProgramiv)(real_program, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetProgramInfoLog)(real_program, len, NULL, info_log);
    
    inspect_action_t action;
    action.type = InspectAction_UpdateProgramInfoLog;
    action.info_log.obj = fake;
    action.info_log.str = info_log;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);


glUseProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);

glIsBuffer:
    ;

glIsList:
    ;

glIsProgram:
    ;

glIsQuery:
    ;

glIsShader:
    ;

glIsTexture:
    ;

glRectd:
    GLdouble x1 = gl_param_GLdouble(command, 0);
    GLdouble y1 = gl_param_GLdouble(command, 1);
    GLdouble x2 = gl_param_GLdouble(command, 2);
    GLdouble y2 = gl_param_GLdouble(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glRectf:
    GLfloat x1 = gl_param_GLfloat(command, 0);
    GLfloat y1 = gl_param_GLfloat(command, 1);
    GLfloat x2 = gl_param_GLfloat(command, 2);
    GLfloat y2 = gl_param_GLfloat(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glRecti:
    GLint x1 = gl_param_GLint(command, 0);
    GLint y1 = gl_param_GLint(command, 1);
    GLint x2 = gl_param_GLint(command, 2);
    GLint y2 = gl_param_GLint(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glRects:
    GLshort x1 = gl_param_GLshort(command, 0);
    GLshort y1 = gl_param_GLshort(command, 1);
    GLshort x2 = gl_param_GLshort(command, 2);
    GLshort y2 = gl_param_GLshort(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glUniform1f:
    GLint loc = gl_param_GLint(command, 0);
    GLfloat v0 = gl_param_GLfloat(command, 1);
    real(loc, v0);

glUniform2f:
    GLint loc = gl_param_GLint(command, 0);
    GLfloat v0 = gl_param_GLfloat(command, 1);
    GLfloat v1 = gl_param_GLfloat(command, 2);
    real(loc, v0, v1);

glUniform3f:
    GLint loc = gl_param_GLint(command, 0);
    GLfloat v0 = gl_param_GLfloat(command, 1);
    GLfloat v1 = gl_param_GLfloat(command, 2);
    GLfloat v2 = gl_param_GLfloat(command, 3);
    real(loc, v0, v1, v2);

glUniform4f:
    GLint loc = gl_param_GLint(command, 0);
    GLfloat v0 = gl_param_GLfloat(command, 1);
    GLfloat v1 = gl_param_GLfloat(command, 2);
    GLfloat v2 = gl_param_GLfloat(command, 3);
    GLfloat v3 = gl_param_GLfloat(command, 4);
    real(loc, v0, v1, v2, v3);

glUniform1i:
    GLint loc = gl_param_GLint(command, 0);
    GLint v0 = gl_param_GLint(command, 1);
    real(loc, v0);

glUniform2i:
    GLint loc = gl_param_GLint(command, 0);
    GLint v0 = gl_param_GLint(command, 1);
    GLint v1 = gl_param_GLint(command, 2);
    real(loc, v0, v1);

glUniform3i:
    GLint loc = gl_param_GLint(command, 0);
    GLint v0 = gl_param_GLint(command, 1);
    GLint v1 = gl_param_GLint(command, 2);
    GLint v2 = gl_param_GLint(command, 3);
    real(loc, v0, v1, v2);

glUniform4i:
    GLint loc = gl_param_GLint(command, 0);
    GLint v0 = gl_param_GLint(command, 1);
    GLint v1 = gl_param_GLint(command, 2);
    GLint v2 = gl_param_GLint(command, 3);
    GLint v3 = gl_param_GLint(command, 4);
    real(loc, v0, v1, v2, v3);

glAreTexturesResident:
    ;

glPrioritizeTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; i++)
        if (!(textures[i] = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake[i])))
            inspect_add_error(inspect_command, "Invalid texture at %zu.", i);
    
    float priorities[n];
    for (size_t i = 0; i < n; i++)
        priorities[i] = trace_get_double(&trace_get_arg(command, 2)->val)[i];
    
    real(n, textures, priorities);

glBindAttribLocation:
    GLuint fake_prog = gl_param_GLuint(command, 0);
    GLuint index = gl_param_GLuint(command, 1);
    const GLchar* name = gl_param_string(command, 2);
    
    GLuint program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_prog);
    if (!program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(program, index, name);

glBeginQuery:
    GLenum target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint id = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake);
    real(target, id);

glGenLists:
    GLsizei range = gl_param_GLsizei(command, 0);
    GLuint fake = *trace_get_uint(&command->ret);
    GLuint real_lists = real(range);
    if (!real_lists) {
        inspect_add_error(inspect_command, "Unable to create lists.");
        return;
    }
    
    for (GLsizei i = 0; i < range; i++)
        replay_create_object(ctx, ReplayObjType_GLDisplayList, real_lists+i, fake+i);

glNewList:
    GLuint fake = gl_param_GLuint(command, 0);
    GLenum mode = gl_param_GLenum(command, 1);
    
    GLuint list = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, fake);
    if (!list) {
        inspect_add_error(inspect_command, "Invalid display list.");
        return;
    }
    
    real(list, mode);

glGenQueries:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint queries[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    real(n, queries);
    
    for (size_t i = 0; i < n; ++i)
        replay_create_object(ctx, ReplayObjType_GLQuery, queries[i], fake[i]);

glDeleteQueries:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint queries[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; ++i)
        if (!(queries[i] = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake[i])))
            inspect_add_error(inspect_command, "Invalid query being deleted.");
    
    real(n, queries);

glDeleteLists:
    GLuint fake = gl_param_GLuint(command, 0);
    GLsizei range = gl_param_GLsizei(command, 1);
    
    GLuint list = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, fake);
    if (!list) {
        inspect_add_error(inspect_command, "Invalid display list.");
        return;
    }
    
    real(list, range);

glCallList:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint list = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, fake);
    if (!list) {
        inspect_add_error(inspect_command, "Invalid display list.");
        return;
    }
    
    real(list);
