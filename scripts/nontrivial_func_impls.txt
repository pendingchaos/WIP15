glXMakeCurrent:
    GLXContext glctx = NULL;
    uint64_t fake_ctx = *trace_get_uint(&trace_get_arg(command, 2)->val);
    if (fake_ctx) {
        glctx = (GLXContext)replay_get_real_object(ctx, ReplayObjType_GLXContext, fake_ctx);
        if (!glctx) {
            inspect_add_error(inspect_command, "Invalid GLX context.");
            return;
        }
    }
    
    if (!real(ctx->_display, glctx ? ctx->_glx_drawable : None, glctx)) {
        inspect_add_error(inspect_command, "Unable to make a context current.");
        return;
    }
    
    if (glctx) {
        reload_gl_funcs(ctx);
        ctx->_current_context = glctx;
    } else {
        reset_gl_funcs(ctx);
        ctx->_current_context = NULL;
    }
    
    if (F(glXSwapIntervalEXT))
        F(glXSwapIntervalEXT)(ctx->_display, ctx->_glx_drawable, 0);
    //TODO
    //else if (F(glXSwapIntervalMESA))
    //    F(glXSwapIntervalMESA)(0);
    else if (F(glXSwapIntervalSGI))
        F(glXSwapIntervalSGI)(0);

glXGetProcAddressARB:
    void (*result)() = real((const GLubyte*)gl_param_string(&trace_get_arg(command, 0)->val));
    if ((result == NULL) != (*trace_get_ptr(&command->ret) == 0))
        inspect_add_warning(inspect_command, "glXGetProcAddress returned NULL when the other did not.");

glXGetProcAddress:
    void (*result)() = real((const GLubyte*)gl_param_string(&trace_get_arg(command, 0)->val));
    if ((result == NULL) != (*trace_get_ptr(&command->ret) == 0))
        inspect_add_warning(inspect_command, "glXGetProcAddress returned NULL when the other did not.");

glXQueryExtension:
    Bool result = real(ctx->_display, NULL, NULL);
    if (result != *trace_get_bool(&command->ret))
        inspect_add_warning(inspect_command, "glXQueryExtension returned something different during replay.");

glXChooseVisual:
    trace_value_t attribs = trace_get_arg(command, 2)->val;
    int int_attribs[attribs.count];
    for (size_t i = 0; i < attribs.count; ++i) {
        union {unsigned int u; int i;} u;
        u.u = trace_get_uint(&attribs)[i];
        int_attribs[i] = u.i;
    }
    XVisualInfo* vis = real(ctx->_display, gl_param_int(&trace_get_arg(command, 1)->val), int_attribs);
    if (!vis) {
        inspect_add_error(inspect_command, "Unable to create visual.");
        return;
    }
    XFree(vis);

glXCreateContext:
    GLXContext shareList = NULL;
    if (*trace_get_ptr(&trace_get_arg(command, 2)->val)) {
        shareList = (GLXContext)replay_get_real_object(ctx,
                                                       ReplayObjType_GLXContext,
                                                       *trace_get_ptr(&trace_get_arg(command, 2)->val));
        if (!shareList) {
            inspect_add_error(inspect_command, "Invalid share list.");
            return;
        }
    }
    GLXContext res = F(glXCreateNewContext)(ctx->_display, ctx->_fbconfig, GLX_RGBA_TYPE, shareList, gl_param_Bool(&trace_get_arg(command, 3)->val));
    replay_create_object(ctx, ReplayObjType_GLXContext, (uint64_t)res, *trace_get_ptr(&command->ret));

glXQueryExtensionsString:
    //Nothing to have here

glXDestroyContext:
    GLXContext glctx = (GLXContext)replay_get_real_object(ctx,
                                                          ReplayObjType_GLXContext,
                                                          *trace_get_ptr(&trace_get_arg(command, 1)->val));
    if (!glctx) {
        inspect_add_error(inspect_command, "Invalid GLX context.");
        return;
    }
    
    real(ctx->_display, glctx);
    replay_destroy_object(ctx, ReplayObjType_GLXContext, *trace_get_ptr(&trace_get_arg(command, 1)->val));

glXSwapBuffers:
    if (!ctx->_current_context) {
        inspect_add_error(inspect_command, "No current OpenGL context.");
        return;
    }
    real(ctx->_display, ctx->_glx_drawable);
    replay_get_back_color(ctx, inspect_command);
    replay_get_front_color(ctx, inspect_command);

glBegin:
    real(gl_param_GLenum(&trace_get_arg(command, 0)->val));
    ctx->_in_begin_end = true;

glEnd:
    real();
    ctx->_in_begin_end = false;
    replay_get_back_color(ctx, inspect_command);
    replay_get_front_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glClear:
    GLbitfield mask = gl_param_GLbitfield(&trace_get_arg(command, 0)->val);
    real(mask);
    if (mask & GL_COLOR_BUFFER_BIT)
        replay_get_back_color(ctx, inspect_command);
    if (mask & GL_DEPTH_BUFFER_BIT)
        replay_get_depth(ctx, inspect_command);

//TODO glDraw* and glEndList

glGenTextures:
    GLsizei n = gl_param_GLsizei(&trace_get_arg(command, 0)->val);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    real(n, textures);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLTexture, textures[i], fake[i]);
        
        inspect_action_t action;
        action.type = InspectAction_GenTexture;
        action.texture = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }

glDeleteTextures:
    GLsizei n = gl_param_GLsizei(&trace_get_arg(command, 0)->val);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; ++i) {
        if (!(textures[i] = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake[i])))
            inspect_add_error(inspect_command, "Invalid texture being deleted.");
        
        inspect_action_t action;
        action.type = InspectAction_DelTexture;
        action.texture = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }
    
    real(n, textures);

glBindTexture:
    GLuint target = gl_param_GLenum(&trace_get_arg(command, 0)->val);
    GLuint fake = gl_param_GLuint(&trace_get_arg(command, 1)->val);
    GLuint real_tex = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake);
    if (!real_tex)
        inspect_add_error(inspect_command, "Invalid texture being bound.");
    real(target, real_tex);
    replay_get_tex_params(ctx, inspect_command, target);

glTexImage2D:
    GLenum target = gl_param_GLenum(&trace_get_arg(command, 0)->val);
    GLint level = gl_param_GLint(&trace_get_arg(command, 1)->val);
    GLint internalFormat = gl_param_GLint(&trace_get_arg(command, 2)->val);
    GLsizei width = gl_param_GLenum(&trace_get_arg(command, 3)->val);
    GLsizei height = gl_param_GLenum(&trace_get_arg(command, 4)->val);
    GLint border = gl_param_GLenum(&trace_get_arg(command, 5)->val);
    GLenum format = gl_param_GLenum(&trace_get_arg(command, 6)->val);
    GLenum type = gl_param_GLenum(&trace_get_arg(command, 7)->val);
    const void* data = gl_param_data(&trace_get_arg(command, 8)->val);
    real(target, level, internalFormat, width, height, border, format, type, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexParameterf:
    GLenum target = gl_param_GLenum(&trace_get_arg(command, 0)->val);
    GLenum pname = gl_param_GLenum(&trace_get_arg(command, 1)->val);
    GLfloat param = gl_param_GLfloat(&trace_get_arg(command, 2)->val);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameteri:
    GLenum target = gl_param_GLenum(&trace_get_arg(command, 0)->val);
    GLenum pname = gl_param_GLenum(&trace_get_arg(command, 1)->val);
    GLint param = gl_param_GLint(&trace_get_arg(command, 2)->val);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glGenBuffers:
    GLsizei n = gl_param_GLsizei(&trace_get_arg(command, 0)->val);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    real(n, buffers);
    
    for (size_t i = 0; i < n; ++i)
        replay_create_object(ctx, ReplayObjType_GLBuffer, buffers[i], fake[i]);

glDeleteBuffers:
    GLsizei n = gl_param_GLsizei(&trace_get_arg(command, 0)->val);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; ++i)
        if (!(buffers[i] = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake[i])))
            inspect_add_error(inspect_command, "Invalid buffer being deleted.");
    
    real(n, buffers);

glBindBuffer:
    GLuint target = gl_param_GLenum(&trace_get_arg(command, 0)->val);
    GLuint fake = gl_param_GLuint(&trace_get_arg(command, 1)->val);
    GLuint real_buf = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake);
    if (!real_buf)
        inspect_add_error(inspect_command, "Invalid buffer being bound.");
    real(target, real_buf);

glBufferData:
    GLuint target = gl_param_GLenum(&trace_get_arg(command, 0)->val);
    GLsizeiptr size = gl_param_GLsizeiptr(&trace_get_arg(command, 1)->val);
    const void* data = gl_param_data(&trace_get_arg(command, 2)->val);
    GLenum usage = gl_param_GLenum(&trace_get_arg(command, 3)->val);
    real(target, size, data, usage);

glBufferSubData:
    GLuint target = gl_param_GLenum(&trace_get_arg(command, 0)->val);
    GLintptr offset = gl_param_GLintptr(&trace_get_arg(command, 1)->val);
    GLsizeiptr size = gl_param_GLsizeiptr(&trace_get_arg(command, 2)->val);
    const void* data = gl_param_data(&trace_get_arg(command, 3)->val);
    real(target, offset, size, data);

glLoadMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glLoadMatrixf:
    F(glLoadMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glLoadTransposeMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glLoadTransposeMatrixf:
    F(glLoadTransposeMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glMultMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glMultMatrixf:
    F(glMultMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glMultTransposeMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glMultTransposeMatrixf:
    F(glMultTransposeMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));
