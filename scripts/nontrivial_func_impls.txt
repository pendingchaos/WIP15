glXMakeCurrent:
    GLXContext glctx = NULL;
    uint64_t fake_ctx = *trace_get_uint(trace_get_arg(command, 2));
    if (fake_ctx) {
        glctx = (GLXContext)replay_get_real_object(ctx, ReplayObjType_GLXContext, fake_ctx);
        if (!glctx) {
            inspect_add_error(inspect_command, "Invalid GLX context.");
            return;
        }
    }
    
    if (!real(ctx->_display, glctx ? ctx->_glx_drawable : None, glctx)) {
        inspect_add_error(inspect_command, "Unable to make a context current.");
        return;
    }
    
    if (glctx) {
        reload_gl_funcs(ctx);
        ctx->_current_context = glctx;
        
        free(ctx->generic_client_arrays);
        
        //TODO: This should use the limits.
        GLint count;
        F(glGetIntegerv)(GL_MAX_VERTEX_ATTRIBS, &count);
        
        ctx->generic_client_array_count = count;
        ctx->generic_client_arrays = malloc(ctx->generic_client_array_count*sizeof(void*));
        for (GLint i = 0; i < count; i++)
            ctx->generic_client_arrays[i] = NULL;
    } else {
        reset_gl_funcs(ctx);
        ctx->_current_context = NULL;
    }
    
    if (F(glXSwapIntervalEXT))
        F(glXSwapIntervalEXT)(ctx->_display, ctx->_glx_drawable, 0);
    //TODO
    //else if (F(glXSwapIntervalMESA))
    //    F(glXSwapIntervalMESA)(0);
    else if (F(glXSwapIntervalSGI))
        F(glXSwapIntervalSGI)(0);

glXGetProcAddressARB:
    void (*result)() = real((const GLubyte*)gl_param_string(command, 0));
    if ((result == NULL) != (*trace_get_ptr(&command->ret) == 0))
        inspect_add_warning(inspect_command, "glXGetProcAddress returned NULL when the other did not.");

glXGetProcAddress:
    void (*result)() = real((const GLubyte*)gl_param_string(command, 0));
    if ((result == NULL) != (*trace_get_ptr(&command->ret) == 0))
        inspect_add_warning(inspect_command, "glXGetProcAddress returned NULL when the other did not.");

glXQueryExtension:
    Bool result = real(ctx->_display, NULL, NULL);
    if (result != *trace_get_bool(&command->ret))
        inspect_add_warning(inspect_command, "glXQueryExtension returned something different during replay.");

glXChooseVisual:
    trace_value_t* attribs = trace_get_arg(command, 2);
    int int_attribs[attribs->count];
    for (size_t i = 0; i < attribs->count; ++i) {
        union {unsigned int u; int i;} u;
        u.u = trace_get_uint(attribs)[i];
        int_attribs[i] = u.i;
    }
    XVisualInfo* vis = real(ctx->_display, gl_param_int(command, 1), int_attribs);
    if (!vis) {
        inspect_add_error(inspect_command, "Unable to create visual.");
        return;
    }
    XFree(vis);

glXCreateContext:
    GLXContext shareList = NULL;
    if (*trace_get_ptr(trace_get_arg(command, 2))) {
        shareList = (GLXContext)replay_get_real_object(ctx,
                                                       ReplayObjType_GLXContext,
                                                       *trace_get_ptr(trace_get_arg(command, 2)));
        if (!shareList) {
            inspect_add_error(inspect_command, "Invalid share list.");
            return;
        }
    }
    GLXContext res = F(glXCreateNewContext)(ctx->_display, ctx->_fbconfig, GLX_RGBA_TYPE, shareList, gl_param_Bool(command, 3));
    replay_create_object(ctx, ReplayObjType_GLXContext, (uint64_t)res, *trace_get_ptr(&command->ret));

glXQueryExtensionsString:
    ;

glXDestroyContext:
    GLXContext glctx = (GLXContext)replay_get_real_object(ctx,
                                                          ReplayObjType_GLXContext,
                                                          *trace_get_ptr(trace_get_arg(command, 1)));
    if (!glctx) {
        inspect_add_error(inspect_command, "Invalid GLX context.");
        return;
    }
    
    real(ctx->_display, glctx);
    replay_destroy_object(ctx, ReplayObjType_GLXContext, *trace_get_ptr(trace_get_arg(command, 1)));

glXSwapBuffers:
    if (!ctx->_current_context) {
        inspect_add_error(inspect_command, "No current OpenGL context.");
        return;
    }
    real(ctx->_display, ctx->_glx_drawable);
    replay_get_back_color(ctx, inspect_command);
    replay_get_front_color(ctx, inspect_command);

glSetContextCapsWIP15:
    ;

glBegin:
    real(gl_param_GLenum(command, 0));
    ctx->_in_begin_end = true;

glEnd:
    real();
    ctx->_in_begin_end = false;
    replay_get_back_color(ctx, inspect_command);
    replay_get_front_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glClear:
    GLbitfield mask = gl_param_GLbitfield(command, 0);
    real(mask);
    if (mask & GL_COLOR_BUFFER_BIT)
        replay_get_back_color(ctx, inspect_command);
    if (mask & GL_DEPTH_BUFFER_BIT)
        replay_get_depth(ctx, inspect_command);

glGenTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, textures);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLTexture, textures[i], fake[i]);
        inspect_act_gen_tex(&inspect_command->state, fake[i]);
    }

glDeleteTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i)
        if (!(textures[i] = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake[i])))
            inspect_add_error(inspect_command, "Invalid texture being deleted.");
        else
            inspect_act_del_tex(&inspect_command->state, fake[i]);
    
    real(n, textures);

glBindTexture:
    GLuint target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint real_tex = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake);
    if (!real_tex && fake)
        inspect_add_error(inspect_command, "Invalid texture being bound.");
    real(target, real_tex);

glTexImage2D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint internalFormat = gl_param_GLint(command, 2);
    GLsizei width = gl_param_GLenum(command, 3);
    GLsizei height = gl_param_GLenum(command, 4);
    GLint border = gl_param_GLenum(command, 5);
    GLenum format = gl_param_GLenum(command, 6);
    GLenum type = gl_param_GLenum(command, 7);
    const void* data = gl_param_data(command, 8);
    real(target, level, internalFormat, width, height, border, format, type, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexParameterf:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    GLfloat param = gl_param_GLfloat(command, 2);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameteri:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    GLint param = gl_param_GLint(command, 2);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameterfv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = trace_get_arg(command, 2);
    GLfloat params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_double(params_val)[i];
    
    real(target, pname, params);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameteriv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = trace_get_arg(command, 2);
    GLint params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_int(params_val)[i];
    
    real(target, pname, params);
    replay_get_tex_params(ctx, inspect_command, target);

glGenBuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, buffers);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLBuffer, buffers[i], fake[i]);
        inspect_act_gen_buf(&inspect_command->state, fake[i]);
    }

glDeleteBuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i) {
        if (!(buffers[i] = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake[i])))
            inspect_add_error(inspect_command, "Invalid buffer being deleted.");
        else
            inspect_act_del_buf(&inspect_command->state, fake[i]);
    }
    
    real(n, buffers);

glBindBuffer:
    GLuint target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint real_buf = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake);
    if (!real_buf && fake)
        inspect_add_error(inspect_command, "Invalid buffer being bound.");
    real(target, real_buf);

glBufferData:
    GLuint target = gl_param_GLenum(command, 0);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 1);
    const void* data = gl_param_data(command, 2);
    GLenum usage = gl_param_GLenum(command, 3);
    real(target, size, data, usage);
    inspect_act_buf_data(&inspect_command->state, get_bound_buffer(ctx, target), size, data, usage);

glBufferSubData:
    GLuint target = gl_param_GLenum(command, 0);
    GLintptr offset = gl_param_GLintptr(command, 1);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 2);
    const void* data = gl_param_data(command, 3);
    real(target, offset, size, data);
    inspect_act_buf_sub_data(&inspect_command->state, get_bound_buffer(ctx, target), offset, size, data);

glMappedBufferDataWIP15:
    GLuint target = gl_param_GLenum(command, 0);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 1);
    const void* data = gl_param_data(command, 2);
    
    F(glUnmapBuffer)(target);
    F(glBufferSubData)(target, 0, size, data);
    inspect_act_buf_sub_data(&inspect_command->state, get_bound_buffer(ctx, target), 0, size, data);

glUnmapBuffer:
    ;

glLoadMatrixd:
    real(trace_get_double(trace_get_arg(command, 0)));

glLoadMatrixf:
    F(glLoadMatrixd)(trace_get_double(trace_get_arg(command, 0)));

glLoadTransposeMatrixd:
    real(trace_get_double(trace_get_arg(command, 0)));

glLoadTransposeMatrixf:
    F(glLoadTransposeMatrixd)(trace_get_double(trace_get_arg(command, 0)));

glMultMatrixd:
    real(trace_get_double(trace_get_arg(command, 0)));

glMultMatrixf:
    F(glMultMatrixd)(trace_get_double(trace_get_arg(command, 0)));

glMultTransposeMatrixd:
    real(trace_get_double(trace_get_arg(command, 0)));

glMultTransposeMatrixf:
    F(glMultTransposeMatrixd)(trace_get_double(trace_get_arg(command, 0)));

glCreateShader:
    GLenum type = gl_param_GLenum(command, 0);
    GLuint real_shdr = F(glCreateShader)(type);
    GLuint fake = trace_get_uint(&command->ret)[0];
    replay_create_object(ctx, ReplayObjType_GLShader, real_shdr, fake);
    inspect_act_new_shdr(&inspect_command->state, fake, type);

glDeleteShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    F(glDeleteShader)(real_shdr);
    
    replay_destroy_object(ctx, ReplayObjType_GLShader, fake);
    inspect_act_del_shdr(&inspect_command->state, fake);

glShaderSource:
    GLuint fake = gl_param_GLuint(command, 0);
    GLsizei count = gl_param_GLsizei(command, 1);
    char** sources = gl_param_string_array(command, 2);
    
    GLuint shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    if (trace_get_arg(command, 3)->count == 0) {
        real(shader, 1, (const GLchar*const*)sources, NULL);
        inspect_act_shdr_source(&inspect_command->state, fake, count, (const char*const*)sources);
    } else {
        uint64_t* lengths64 = trace_get_uint(trace_get_arg(command, 3));
        
        GLint lengths[count];
        for (GLsizei i = 0; i < count; i++) {
            lengths[i] = lengths64[i];
        }
        
        real(shader, count, (const GLchar*const*)sources, lengths);
        
        char* new_sources[count];
        for (GLsizei i = 0; i < count; i++) {
            new_sources[i] = malloc(lengths[i]+1);
            memcpy(new_sources[i], sources[i], lengths[i]);
            new_sources[i][lengths[i]] = 0;
        }
        
        inspect_act_shdr_source(&inspect_command->state, fake, count, (const char*const*)new_sources);
        
        for (GLsizei i = 0; i < count; i++)
            free(new_sources[i]);
    }

glCompileShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    real(real_shdr);
    
    GLint status;
    F(glGetShaderiv)(real_shdr, GL_COMPILE_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Unable to compile shader.");
    
    GLint len;
    F(glGetShaderiv)(real_shdr, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetShaderInfoLog)(real_shdr, len, NULL, info_log);
    
    inspect_act_set_shdr_info_log(&inspect_command->state, fake, info_log);
    
    free(info_log);

glCreateProgram:
    GLuint real_program = F(glCreateProgram)();
    GLuint fake = trace_get_uint(&command->ret)[0];
    replay_create_object(ctx, ReplayObjType_GLProgram, real_program, fake);
    inspect_act_new_prog(&inspect_command->state, fake);

glDeleteProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);
    
    replay_destroy_object(ctx, ReplayObjType_GLProgram, fake);
    inspect_act_del_prog(&inspect_command->state, fake);

glAttachShader:
    GLuint fake_program = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_program);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    GLuint fake_shader = gl_param_GLuint(command, 1);
    GLuint real_shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake_shader);
    if (!real_shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    real(real_program, real_shader);
    
    inspect_act_attach_shdr(&inspect_command->state, fake_program, fake_shader);

glDetachShader:
    GLuint fake_program = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_program);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    GLuint fake_shader = gl_param_GLuint(command, 1);
    GLuint real_shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake_shader);
    if (!real_shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    real(real_program, real_shader);
    
    inspect_act_detach_shdr(&inspect_command->state, fake_program, fake_shader);

glLinkProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);
    
    GLint status;
    F(glGetProgramiv)(real_program, GL_LINK_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Unable to link program.");
    
    GLint len;
    F(glGetProgramiv)(real_program, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetProgramInfoLog)(real_program, len, NULL, info_log);
    
    inspect_act_set_prog_info_log(&inspect_command->state, fake, info_log);
    
    free(info_log);

glValidateProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);
    
    GLint status;
    F(glGetProgramiv)(real_program, GL_LINK_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Program validation failed.");
    
    GLint len;
    F(glGetProgramiv)(real_program, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetProgramInfoLog)(real_program, len, NULL, info_log);
    
    inspect_act_set_prog_info_log(&inspect_command->state, fake, info_log);
    
    free(info_log);

glUseProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);

glIsBuffer:
    ;

glIsList:
    ;

glIsProgram:
    ;

glIsQuery:
    ;

glIsShader:
    ;

glIsTexture:
    ;

glRectd:
    GLdouble x1 = gl_param_GLdouble(command, 0);
    GLdouble y1 = gl_param_GLdouble(command, 1);
    GLdouble x2 = gl_param_GLdouble(command, 2);
    GLdouble y2 = gl_param_GLdouble(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glRectf:
    GLfloat x1 = gl_param_GLfloat(command, 0);
    GLfloat y1 = gl_param_GLfloat(command, 1);
    GLfloat x2 = gl_param_GLfloat(command, 2);
    GLfloat y2 = gl_param_GLfloat(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glRecti:
    GLint x1 = gl_param_GLint(command, 0);
    GLint y1 = gl_param_GLint(command, 1);
    GLint x2 = gl_param_GLint(command, 2);
    GLint y2 = gl_param_GLint(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glRects:
    GLshort x1 = gl_param_GLshort(command, 0);
    GLshort y1 = gl_param_GLshort(command, 1);
    GLshort x2 = gl_param_GLshort(command, 2);
    GLshort y2 = gl_param_GLshort(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glAreTexturesResident:
    ;

glPrioritizeTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; i++)
        if (!(textures[i] = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake[i])))
            inspect_add_error(inspect_command, "Invalid texture at %zu.", i);
    
    float priorities[n];
    for (size_t i = 0; i < n; i++)
        priorities[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(n, textures, priorities);

glBindAttribLocation:
    GLuint fake_prog = gl_param_GLuint(command, 0);
    GLuint index = gl_param_GLuint(command, 1);
    const GLchar* name = gl_param_string(command, 2);
    
    GLuint program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_prog);
    if (!program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(program, index, name);

glBeginQuery:
    GLenum target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint id = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake);
    real(target, id);

glGenLists:
    GLsizei range = gl_param_GLsizei(command, 0);
    GLuint fake = *trace_get_uint(&command->ret);
    GLuint real_lists = real(range);
    if (!real_lists) {
        inspect_add_error(inspect_command, "Unable to create lists.");
        return;
    }
    
    for (GLsizei i = 0; i < range; i++)
        replay_create_object(ctx, ReplayObjType_GLDisplayList, real_lists+i, fake+i);

glNewList:
    GLuint fake = gl_param_GLuint(command, 0);
    GLenum mode = gl_param_GLenum(command, 1);
    
    GLuint list = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, fake);
    if (!list) {
        inspect_add_error(inspect_command, "Invalid display list.");
        return;
    }
    
    real(list, mode);

glGenQueries:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint queries[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    real(n, queries);
    
    for (size_t i = 0; i < n; ++i)
        replay_create_object(ctx, ReplayObjType_GLQuery, queries[i], fake[i]);

glDeleteQueries:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint queries[n];
    uint64_t* fake = trace_get_uint(trace_get_arg(command, 1));
    
    for (size_t i = 0; i < n; ++i)
        if (!(queries[i] = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake[i])))
            inspect_add_error(inspect_command, "Invalid query being deleted.");
    
    real(n, queries);

glDeleteLists:
    GLuint fake = gl_param_GLuint(command, 0);
    GLsizei range = gl_param_GLsizei(command, 1);
    
    GLuint list = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, fake);
    if (!list) {
        inspect_add_error(inspect_command, "Invalid display list.");
        return;
    }
    
    real(list, range);

glCallList:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint list = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, fake);
    if (!list) {
        inspect_add_error(inspect_command, "Invalid display list.");
        return;
    }
    
    real(list);

glGetUniformfv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glGetUniformiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glGetAttribLocation:
    GLuint fake = gl_param_GLuint(command, 0);
    const GLchar* name = gl_param_string(command, 1);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    if (real(real_program, name) < 0)
        inspect_add_error(inspect_command, "No such attribute \"%s\".", name);

glGetUniformLocation:
    GLuint fake = gl_param_GLuint(command, 0);
    const GLchar* name = gl_param_string(command, 1);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    if (real(real_program, name) < 0)
        inspect_add_error(inspect_command, "No such uniform \"%s\".", name);

glGetShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr)
        inspect_add_error(inspect_command, "Invalid shader.");

glGetShaderInfoLog:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr)
        inspect_add_error(inspect_command, "Invalid shader.");

glGetShaderSource:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr)
        inspect_add_error(inspect_command, "Invalid shader.");

glGetQueryiv:
    ;

glGetQueryObjectiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_query = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake);
    if (!real_query)
        inspect_add_error(inspect_command, "Invalid query.");

glGetQueryObjectuiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_query = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake);
    if (!real_query)
        inspect_add_error(inspect_command, "Invalid query.");

glGetProgramInfoLog:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_prog = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_prog)
        inspect_add_error(inspect_command, "Invalid program.");

glGetProgramiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_prog = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_prog)
        inspect_add_error(inspect_command, "Invalid program.");

glGetLightfv:
    ;

glGetLightfiv:
    ;

glGetMaterialfv:
    ;

glGetMaterialiv:
    ;

glGetMapdv:
    ;

glGetMapfv:
    ;

glGetMapiv:
    ;

glGetHistogram:
    ;

glGetHistogramParameterfv:
    ;

glGetHistogramParameteriv:
    ;

glGetConvolutionFilter:
    ;

glGetConvolutionParameterfv:
    ;

glGetConvolutionParameteriv:
    ;

glGetClipPlane:
    ;

glGetTexEnvfv:
    ;

glGetTexEnviv:
    ;

glGetTexGendv:
    ;

glGetTexGenfv:
    ;

glGetTexGeniv:
    ;

glGetTexLevelParameterfv:
    ;

glGetTexLevelParameteriv:
    ;

glGetTexParameterfv:
    ;

glGetTexParameteriv:
    ;

glGetPointerv:
    ;

glGetPolygonStipple:
    ;

glGetMinmax:
    ;

glGetMinmaxParameterfv:
    ;

glGetMinmaxParameteriv:
    ;

glGetPixelMapfv:
    ;

glGetPixelMapuiv:
    ;

glGetPixelMapusv:
    ;

glGetSeparableFilter:
    ;

glGetBufferParameteriv:
    ;

glGetBufferPointerv:
    ;

glGetBufferSubData:
    ;

glGetTexImage:
    ;

glGetBooleanv:
    ;

glGetDoublev:
    ;

glGetFloatv:
    ;

glGetIntegerv:
    ;

glGetVertexAttribdv:
    ;

glGetVertexAttrivfv:
    ;

glGetVertexAttribiv:
    ;

glGetVertexAttribPointerv:
    ;

glGetCompressedTexImage:
    ;

glGetColorTableParameterfv:
    ;

glGetColorTableParameteriv:
    ;

glGetColorTable:
    ;

glGetAttachedShaders:
    ;

glGetActiveUniform:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glGetActiveAttrib:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glCallLists:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLenum type = gl_param_GLenum(command, 1);
    void* lists = gl_param_data(command, 2);
    
    int64_t real_lists[n];
    for (GLsizei i = 0; i < n; i++) {
        switch (type) {
        case GL_BYTE:
            real_lists[i] = ((int8_t*)lists)[i];
            break;
        case GL_UNSIGNED_BYTE:
            real_lists[i] = ((uint8_t*)lists)[i];
            break;
        case GL_SHORT:
            real_lists[i] = ((int16_t*)lists)[i];
            break;
        case GL_UNSIGNED_SHORT:
            real_lists[i] = ((uint16_t*)lists)[i];
            break;
        case GL_INT:
            real_lists[i] = ((int32_t*)lists)[i];
            break;
        case GL_UNSIGNED_INT:
            real_lists[i] = ((uint32_t*)lists)[i];
            break;
        case GL_FLOAT:
            real_lists[i] = ((float*)lists)[i];
            break;
        case GL_2_BYTES:
            real_lists[i] = ((uint8_t*)lists)[i*2]*256 +
                            ((uint8_t*)lists)[i*2+1];
            break;
        case GL_3_BYTES:
            real_lists[i] = ((uint8_t*)lists)[i*3]*65536u +
                            ((uint8_t*)lists)[i*3+1]*256u +
                            ((uint8_t*)lists)[i*3+2];
            break;
        case GL_4_BYTES:
            real_lists[i] = ((uint8_t*)lists)[i*3]*16777216u +
                            ((uint8_t*)lists)[i*3+1]*65536u +
                            ((uint8_t*)lists)[i*3+2]*256u +
                            ((uint8_t*)lists)[i*3+3];
            break;
        default:
            inspect_add_error(inspect_command, "Invalid type.");
            return;
        }
    }
    
    GLint base;
    F(glGetIntegerv)(GL_LIST_BASE, &base);
    
    GLuint gl_lists[n];
    for (GLsizei i = 0; i < n; i++) {
        real_lists[i] += base;
        GLuint real = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, real_lists[i]);
        if ((real_lists[i] < 0) || !real) {
            inspect_add_error(inspect_command, "Invalid display list at %d.\n", (int)i);
            return;
        }
        gl_lists[i] = real;
    }
    
    real(n, GL_UNSIGNED_INT, gl_lists);

glReadPixels:
    ;

glLightModelfv:
    GLenum pname = gl_param_GLenum(command, 0);
    
    trace_value_t* params_val = trace_get_arg(command, 1);
    GLfloat params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_double(params_val)[i];
    
    real(pname, params);

glLightModeliv:
    GLenum pname = gl_param_GLenum(command, 0);
    
    trace_value_t* params_val = trace_get_arg(command, 1);
    GLint params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_int(params_val)[i];
    
    real(pname, params);

glLightfv:
    GLenum light = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = trace_get_arg(command, 2);
    GLfloat params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_double(params_val)[i];
    
    real(light, pname, params);

glLightiv:
    GLenum light = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = trace_get_arg(command, 2);
    GLint params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_int(params_val)[i];
    
    real(light, pname, params);

glMaterialfv:
    GLenum face = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = trace_get_arg(command, 2);
    GLfloat params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_double(params_val)[i];
    
    real(face, pname, params);

glMaterialiv:
    GLenum face = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = trace_get_arg(command, 2);
    GLint params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_int(params_val)[i];
    
    real(face, pname, params);

glNormal3bv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glNormal3b)(v[0], v[1], v[2]);

glNormal3dv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glNormal3d)(v[0], v[1], v[2]);

glNormal3fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glNormal3f)(v[0], v[1], v[2]);

glNormal3iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glNormal3i)(v[0], v[1], v[2]);

glNormal3sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glNormal3s)(v[0], v[1], v[2]);

glVertex2sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glVertex2s)(v[0], v[1]);

glVertex2iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glVertex2i)(v[0], v[1]);

glVertex2fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glVertex2f)(v[0], v[1]);

glVertex2dv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glVertex2d)(v[0], v[1]);

glVertex3sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glVertex3s)(v[0], v[1], v[2]);

glVertex3iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glVertex3i)(v[0], v[1], v[2]);

glVertex3fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glVertex3f)(v[0], v[1], v[2]);

glVertex3dv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glVertex3d)(v[0], v[1], v[2]);

glVertex4sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glVertex4s)(v[0], v[1], v[2], v[3]);

glVertex4iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glVertex4i)(v[0], v[1], v[2], v[3]);

glVertex4fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glVertex4f)(v[0], v[1], v[2], v[3]);

glVertex4dv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glVertex4d)(v[0], v[1], v[2], v[3]);

glTexCoord1sv:
    F(glTexCoord1s)(gl_param_GLshort(command, 0));

glTexCoord1iv:
    F(glTexCoord1i)(gl_param_GLint(command, 0));

glTexCoord1fv:
    F(glTexCoord1f)(gl_param_GLfloat(command, 0));

glTexCoord1dv:
    F(glTexCoord1d)(gl_param_GLdouble(command, 0));

glTexCoord2sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glTexCoord2s(v[0], v[1]));

glTexCoord2iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glTexCoord2i(v[0], v[1]));

glTexCoord2fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glTexCoord2f(v[0], v[1]));

glTexCoord2dv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glTexCoord2d(v[0], v[1]));

glTexCoord3sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glTexCoord3s(v[0], v[1], v[2]));

glTexCoord3iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glTexCoord3i(v[0], v[1], v[2]));

glTexCoord3fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glTexCoord3f(v[0], v[1], v[2]));

glTexCoord3dv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glTexCoord3d(v[0], v[1], v[2]));

glTexCoord4sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glTexCoord4s(v[0], v[1], v[2], v[3]));

glTexCoord4iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glTexCoord4i(v[0], v[1], v[2], v[3]));

glTexCoord4fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glTexCoord4f(v[0], v[1], v[2], v[3]));

glTexCoord4dv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glTexCoord4d(v[0], v[1], v[2], v[3]));

glIndexsv:
    F(glIndexs)(gl_param_GLshort(command, 0));

glIndexiv:
    F(glIndexi)(gl_param_GLint(command, 0));

glIndexfv:
    F(glIndexf)(gl_param_GLfloat(command, 0));

glIndexdv:
    F(glIndexd)(gl_param_GLdouble(command, 0));

glIndexubv:
    F(glIndexub)(gl_param_GLubyte(command, 0));

glFogCoorddv:
    F(glFogCoordd)(gl_param_GLdouble(command, 0));

glFogCoordfv:
    F(glFogCoordf)(gl_param_GLfloat(command, 0));

glEdgeFlagv:
    F(glEdgeFlag)(gl_param_GLboolean(command, 0));

glColor3bv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor3b)(v[0], v[1], v[2]);

glColor3sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor3s)(v[0], v[1], v[2]);

glColor3iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor3i)(v[0], v[1], v[2]);

glColor3fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glColor3f)(v[0], v[1], v[2]);

glColor3dv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glColor3d)(v[0], v[1], v[2]);

glColor3ubv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor3ub)(v[0], v[1], v[2]);

glColor3usv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor3us)(v[0], v[1], v[2]);

glColor3uiv:
    uint64_t* v = trace_get_uint(trace_get_arg(command, 0));
    F(glColor3ui)(v[0], v[1], v[2]);

glColor4bv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor4b)(v[0], v[1], v[2], v[3]);

glColor4sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor4s)(v[0], v[1], v[2], v[3]);

glColor4iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor4i)(v[0], v[1], v[2], v[3]);

glColor4fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glColor4f)(v[0], v[1], v[2], v[3]);

glColor4dv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glColor4d)(v[0], v[1], v[2], v[3]);

glColor4ubv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor4ub)(v[0], v[1], v[2], v[3]);

glColor4usv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glColor4us)(v[0], v[1], v[2], v[3]);

glColor4uiv:
    uint64_t* v = trace_get_uint(trace_get_arg(command, 0));
    F(glColor4ui)(v[0], v[1], v[2], v[3]);

glRectdv:
    double *v1 = trace_get_double(trace_get_arg(command, 0));
    double *v2 = trace_get_double(trace_get_arg(command, 1));
    F(glRectd)(v1[0], v1[1], v2[0], v2[1]);

glRectfv:
    double *v1 = trace_get_double(trace_get_arg(command, 0));
    double *v2 = trace_get_double(trace_get_arg(command, 1));
    F(glRectf)(v1[0], v1[1], v2[0], v2[1]);

glRectiv:
    int64_t *v1 = trace_get_int(trace_get_arg(command, 0));
    int64_t *v2 = trace_get_int(trace_get_arg(command, 1));
    F(glRecti)(v1[0], v1[1], v2[0], v2[1]);

glRectsv:
    int64_t *v1 = trace_get_int(trace_get_arg(command, 0));
    int64_t *v2 = trace_get_int(trace_get_arg(command, 1));
    F(glRects)(v1[0], v1[1], v2[0], v2[1]);

glProgramUniformWIP15:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    GLint loc = F(glGetUniformLocation)(real_program, gl_param_string(command, 1));
    if (loc < 0) {
        inspect_add_error(inspect_command, "Nonexistent or inactive uniform.");
        return;
    }
    
    replay_add_uniform(ctx, fake, gl_param_GLuint(command, 2), loc);

glUniform1f:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    real(loc, gl_param_GLfloat(command, 1));

glUniform2f:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    real(loc, gl_param_GLfloat(command, 1), gl_param_GLfloat(command, 2));

glUniform3f:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    real(loc,
         gl_param_GLfloat(command, 1),
         gl_param_GLfloat(command, 2),
         gl_param_GLfloat(command, 3));

glUniform4f:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    real(loc,
         gl_param_GLfloat(command, 1),
         gl_param_GLfloat(command, 2),
         gl_param_GLfloat(command, 3),
         gl_param_GLfloat(command, 4));

glUniform1i:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    real(loc, gl_param_GLint(command, 1));

glUniform2i:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    real(loc, gl_param_GLint(command, 1), gl_param_GLint(command, 2));

glUniform3i:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    real(loc,
         gl_param_GLint(command, 1),
         gl_param_GLint(command, 2),
         gl_param_GLint(command, 3));

glUniform4i:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    real(loc,
         gl_param_GLint(command, 1),
         gl_param_GLint(command, 2),
         gl_param_GLint(command, 3),
         gl_param_GLint(command, 4));

glUniform1fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform2fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0; i < count*2; i++)
        values[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform3fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0; i < count*3; i++)
        values[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform4fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0; i < count*4; i++)
        values[i] = trace_get_double(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform1iv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLint values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_int(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform2iv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLint values[count];
    for (GLsizei i = 0 ; i < count*2; i++)
        values[i] = trace_get_int(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform3iv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLint values[count];
    for (GLsizei i = 0 ; i < count*3; i++)
        values[i] = trace_get_int(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniform4iv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLint values[count];
    for (GLsizei i = 0 ; i < count*4; i++)
        values[i] = trace_get_int(trace_get_arg(command, 2))[i];
    
    real(loc, count, values);

glUniformMatrix2fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix3fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix4fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix2x3fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix3x2fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix2x4fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix4x2fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix3x4fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glUniformMatrix4x3fv:
    GLint loc;
    if (uniform(ctx, command, &loc))
        return;
    
    GLsizei count = gl_param_GLint(command, 1);
    GLfloat values[count];
    for (GLsizei i = 0 ; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 3))[i];
    
    real(loc, count, gl_param_GLboolean(command, 2), values);

glProgramAttribWIP15:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    GLint loc = F(glGetAttribLocation)(real_program, gl_param_string(command, 1));
    if (loc < 0) {
        inspect_add_error(inspect_command, "Nonexistent or inactive uniform.");
        return;
    }
    
    replay_add_attrib(ctx, fake, gl_param_GLuint(command, 2), loc);

glVertexAttribPointer:
    GLint idx;
    if (attrib(ctx, command, &idx))
        return;
    
    real(idx,
         gl_param_GLint(command, 1),
         gl_param_GLenum(command, 2),
         gl_param_GLboolean(command, 3),
         gl_param_GLsizei(command, 4),
         (const GLvoid*)gl_param_pointer(command, 5));

glEnableVertexAttribArray:
    GLint idx;
    if (attrib(ctx, command, &idx))
        return;
    
    real(idx);

glDisableVertexAttribArray:
    GLint idx;
    if (attrib(ctx, command, &idx))
        return;
    
    real(idx);

glClientColorDataWIP15:
    client_array(ctx, command, ReplayClientArr_Color);

glClientEdgeFlagDataWIP15:
    client_array(ctx, command, ReplayClientArr_EdgeFlag);

glClientFogCoordDataWIP15:
    client_array(ctx, command, ReplayClientArr_FogCoord);

glClientIndexDataWIP15:
    client_array(ctx, command, ReplayClientArr_Index);

glClientNormalDataWIP15:
    client_array(ctx, command, ReplayClientArr_Normal);

glClientSecondaryColorDataWIP15:
    client_array(ctx, command, ReplayClientArr_SecondaryColor);

glClientTextureCoordDataWIP15:
    client_array(ctx, command, ReplayClientArr_TextureCoord);

glClientVertexDataWIP15:
    client_array(ctx, command, ReplayClientArr_Vertex);

glClientGenericAttribDataWIP15:
    GLuint index = gl_param_GLuint(command, 0);
    GLsizei size = gl_param_GLsizei(command, 1);
    
    if (index < ctx->generic_client_array_count) {
        void* data = malloc(size);
        memcpy(data, gl_param_data(command, 2), size);
        free(ctx->generic_client_arrays[index]);
        ctx->generic_client_arrays[index] = data;
    }

glDrawArrays:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLint first = gl_param_GLint(command, 1);
    GLsizei count = gl_param_GLsizei(command, 2);
    real(mode, first, count);
    
    end_draw(ctx, inspect_command);

glMultiDrawArrays:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    int64_t* first64 = trace_get_int(trace_get_arg(command, 1));
    int64_t* count64 = trace_get_int(trace_get_arg(command, 2));
    GLsizei primcount = gl_param_GLsizei(command, 3);
    
    GLint first[primcount];
    GLint count[primcount];
    for (GLsizei i = 0; i < primcount; i++) {
        first[i] = first64[i];
        count[i] = count64[i];
    }
    
    real(mode, first, count, primcount);
    
    end_draw(ctx, inspect_command);

glDrawElements:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLsizei count = gl_param_GLsizei(command, 1);
    GLenum type = gl_param_GLenum(command, 2);
    
    GLint element_buf;
    F(glGetIntegerv)(GL_ELEMENT_ARRAY_BUFFER_BINDING, &element_buf);
    const GLvoid* indices;
    if (element_buf)
        indices = (const GLvoid*)gl_param_pointer(command, 3);
    else
        indices = gl_param_data(command, 3);
    
    real(mode, count, type, indices);
    
    end_draw(ctx, inspect_command);

glDrawRangeElements:
    begin_draw(ctx);
    
    GLenum mode = gl_param_GLenum(command, 0);
    GLuint start = gl_param_GLuint(command, 1);
    GLuint end = gl_param_GLuint(command, 2);
    GLsizei count = gl_param_GLsizei(command, 3);
    GLenum type = gl_param_GLenum(command, 4);
    
    GLint element_buf;
    F(glGetIntegerv)(GL_ELEMENT_ARRAY_BUFFER_BINDING, &element_buf);
    const GLvoid* indices;
    if (element_buf)
        indices = (const GLvoid*)gl_param_pointer(command, 5);
    else
        indices = gl_param_data(command, 5);
    
    real(mode, start, end, count, type, indices);
    
    end_draw(ctx, inspect_command);

glPointParameterfv:
    size_t count = trace_get_arg(command, 1)->count;
    GLfloat values[count];
    for (size_t i = 0; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 1))[i];
    real(gl_param_GLenum(command, 0), values);

glPointParameteriv:
    size_t count = trace_get_arg(command, 1)->count;
    GLint values[count];
    for (size_t i = 0; i < count; i++)
        values[i] = trace_get_int(trace_get_arg(command, 1))[i];
    real(gl_param_GLenum(command, 0), values);

glClipPlane:
    real(gl_param_GLenum(command, 0), trace_get_double(trace_get_arg(command, 1)));

glTexEnvfv:
    size_t count = trace_get_arg(command, 2)->count;
    GLfloat values[count];
    for (size_t i = 0; i < count; i++)
        values[i] = trace_get_double(trace_get_arg(command, 1))[i];
    real(gl_param_GLenum(command, 0), gl_param_GLenum(command, 1), values);

glTexEnviv:
    size_t count = trace_get_arg(command, 2)->count;
    GLint values[count];
    for (size_t i = 0; i < count; i++)
        values[i] = trace_get_int(trace_get_arg(command, 1))[i];
    real(gl_param_GLenum(command, 0), gl_param_GLenum(command, 1), values);

glTexGeniv:
    size_t count = trace_get_arg(command, 2)->count;
    GLint values[count];
    for (size_t i = 0; i < count; i++)
        values[i] = trace_get_int(trace_get_arg(command, 1))[i];
    real(gl_param_GLenum(command, 0), gl_param_GLenum(command, 1), values);

glTexGenfv:
    F(glTexGendv)(gl_param_GLenum(command, 0),
                  gl_param_GLenum(command, 1),
                  trace_get_double(trace_get_arg(command, 2)));

glTexGendv:
    F(glTexGendv)(gl_param_GLenum(command, 0),
                  gl_param_GLenum(command, 1),
                  trace_get_double(trace_get_arg(command, 2)));

glWindowPos2sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glWindowPos2s)(v[0], v[1]);

glWindowPos2iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glWindowPos2i)(v[0], v[1]);

glWindowPos2fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glWindowPos2f)(v[0], v[1]);

glWindowPos2dv:
    F(glWindowPos2dv)(trace_get_double(trace_get_arg(command, 0)));

glWindowPos3sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glWindowPos3s)(v[0], v[1], v[2]);

glWindowPos3iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glWindowPos3i)(v[0], v[1], v[2]);

glWindowPos3fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glWindowPos3f)(v[0], v[1], v[2]);

glWindowPos3dv:
    F(glWindowPos3dv)(trace_get_double(trace_get_arg(command, 0)));

glRasterPos2sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glRasterPos2s)(v[0], v[1]);

glRasterPos2iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glRasterPos2i)(v[0], v[1]);

glRasterPos2fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glRasterPos2f)(v[0], v[1]);

glRasterPos2dv:
    F(glRasterPos2dv)(trace_get_double(trace_get_arg(command, 0)));

glRasterPos3sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glRasterPos3s)(v[0], v[1], v[2]);

glRasterPos3iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glRasterPos3i)(v[0], v[1], v[2]);

glRasterPos3fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glRasterPos3f)(v[0], v[1], v[2]);

glRasterPos3dv:
    F(glRasterPos3dv)(trace_get_double(trace_get_arg(command, 0)));

glRasterPos4sv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glRasterPos4s)(v[0], v[1], v[2], v[3]);

glRasterPos4iv:
    int64_t* v = trace_get_int(trace_get_arg(command, 0));
    F(glRasterPos4i)(v[0], v[1], v[2], v[3]);

glRasterPos4fv:
    double* v = trace_get_double(trace_get_arg(command, 0));
    F(glRasterPos4f)(v[0], v[1], v[2], v[3]);

glRasterPos4dv:
    F(glRasterPos4dv)(trace_get_double(trace_get_arg(command, 0)));
