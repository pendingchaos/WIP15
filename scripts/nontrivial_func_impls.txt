glXMakeCurrent:
    GLXContext glctx = NULL;
    uint64_t fake_ctx = *trace_get_uint(&trace_get_arg(command, 2)->val);
    if (fake_ctx) {
        glctx = (GLXContext)replay_get_real_object(ctx, ReplayObjType_GLXContext, fake_ctx);
        if (!glctx) {
            inspect_add_error(inspect_command, "Invalid GLX context.");
            return;
        }
    }
    
    if (!real(ctx->_display, glctx ? ctx->_glx_drawable : None, glctx)) {
        inspect_add_error(inspect_command, "Unable to make a context current.");
        return;
    }
    
    if (glctx) {
        reload_gl_funcs(ctx);
        ctx->_current_context = glctx;
    } else {
        reset_gl_funcs(ctx);
        ctx->_current_context = NULL;
    }
    
    if (F(glXSwapIntervalEXT))
        F(glXSwapIntervalEXT)(ctx->_display, ctx->_glx_drawable, 0);
    //TODO
    //else if (F(glXSwapIntervalMESA))
    //    F(glXSwapIntervalMESA)(0);
    else if (F(glXSwapIntervalSGI))
        F(glXSwapIntervalSGI)(0);

glXGetProcAddressARB:
    void (*result)() = real((const GLubyte*)gl_param_string(command, 0));
    if ((result == NULL) != (*trace_get_ptr(&command->ret) == 0))
        inspect_add_warning(inspect_command, "glXGetProcAddress returned NULL when the other did not.");

glXGetProcAddress:
    void (*result)() = real((const GLubyte*)gl_param_string(command, 0));
    if ((result == NULL) != (*trace_get_ptr(&command->ret) == 0))
        inspect_add_warning(inspect_command, "glXGetProcAddress returned NULL when the other did not.");

glXQueryExtension:
    Bool result = real(ctx->_display, NULL, NULL);
    if (result != *trace_get_bool(&command->ret))
        inspect_add_warning(inspect_command, "glXQueryExtension returned something different during replay.");

glXChooseVisual:
    trace_value_t attribs = trace_get_arg(command, 2)->val;
    int int_attribs[attribs.count];
    for (size_t i = 0; i < attribs.count; ++i) {
        union {unsigned int u; int i;} u;
        u.u = trace_get_uint(&attribs)[i];
        int_attribs[i] = u.i;
    }
    XVisualInfo* vis = real(ctx->_display, gl_param_int(command, 1), int_attribs);
    if (!vis) {
        inspect_add_error(inspect_command, "Unable to create visual.");
        return;
    }
    XFree(vis);

glXCreateContext:
    GLXContext shareList = NULL;
    if (*trace_get_ptr(&trace_get_arg(command, 2)->val)) {
        shareList = (GLXContext)replay_get_real_object(ctx,
                                                       ReplayObjType_GLXContext,
                                                       *trace_get_ptr(&trace_get_arg(command, 2)->val));
        if (!shareList) {
            inspect_add_error(inspect_command, "Invalid share list.");
            return;
        }
    }
    GLXContext res = F(glXCreateNewContext)(ctx->_display, ctx->_fbconfig, GLX_RGBA_TYPE, shareList, gl_param_Bool(command, 3));
    replay_create_object(ctx, ReplayObjType_GLXContext, (uint64_t)res, *trace_get_ptr(&command->ret));

glXQueryExtensionsString:
    ;

glXDestroyContext:
    GLXContext glctx = (GLXContext)replay_get_real_object(ctx,
                                                          ReplayObjType_GLXContext,
                                                          *trace_get_ptr(&trace_get_arg(command, 1)->val));
    if (!glctx) {
        inspect_add_error(inspect_command, "Invalid GLX context.");
        return;
    }
    
    real(ctx->_display, glctx);
    replay_destroy_object(ctx, ReplayObjType_GLXContext, *trace_get_ptr(&trace_get_arg(command, 1)->val));

glXSwapBuffers:
    if (!ctx->_current_context) {
        inspect_add_error(inspect_command, "No current OpenGL context.");
        return;
    }
    real(ctx->_display, ctx->_glx_drawable);
    replay_get_back_color(ctx, inspect_command);
    replay_get_front_color(ctx, inspect_command);

glSetContextCapsWIP15:
    ;

glBegin:
    real(gl_param_GLenum(command, 0));
    ctx->_in_begin_end = true;

glEnd:
    real();
    ctx->_in_begin_end = false;
    replay_get_back_color(ctx, inspect_command);
    replay_get_front_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glClear:
    GLbitfield mask = gl_param_GLbitfield(command, 0);
    real(mask);
    if (mask & GL_COLOR_BUFFER_BIT)
        replay_get_back_color(ctx, inspect_command);
    if (mask & GL_DEPTH_BUFFER_BIT)
        replay_get_depth(ctx, inspect_command);

glDrawArrays:
    GLenum mode = gl_param_GLenum(command, 0);
    GLint first = gl_param_GLint(command, 1);
    GLsizei count = gl_param_GLsizei(command, 2);
    real(mode, first, count);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glMultiDrawArrays:
    GLenum mode = gl_param_GLenum(command, 0);
    int64_t* first64 = trace_get_int(&trace_get_arg(command, 1)->val);
    int64_t* count64 = trace_get_int(&trace_get_arg(command, 2)->val);
    GLsizei primcount = gl_param_GLsizei(command, 3);
    
    GLint first[primcount];
    GLint count[primcount];
    for (GLsizei i = 0; i < primcount; i++) {
        first[i] = first64[i];
        count[i] = count64[i];
    }
    
    real(mode, first, count, primcount);
    
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glGenTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    real(n, textures);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLTexture, textures[i], fake[i]);
        
        inspect_action_t action;
        action.type = InspectAction_GenTexture;
        action.texture = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }

glDeleteTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; ++i) {
        if (!(textures[i] = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake[i])))
            inspect_add_error(inspect_command, "Invalid texture being deleted.");
        
        inspect_action_t action;
        action.type = InspectAction_DelTexture;
        action.texture = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }
    
    real(n, textures);

glBindTexture:
    GLuint target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint real_tex = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake);
    if (!real_tex)
        inspect_add_error(inspect_command, "Invalid texture being bound.");
    real(target, real_tex);

glTexImage2D:
    GLenum target = gl_param_GLenum(command, 0);
    GLint level = gl_param_GLint(command, 1);
    GLint internalFormat = gl_param_GLint(command, 2);
    GLsizei width = gl_param_GLenum(command, 3);
    GLsizei height = gl_param_GLenum(command, 4);
    GLint border = gl_param_GLenum(command, 5);
    GLenum format = gl_param_GLenum(command, 6);
    GLenum type = gl_param_GLenum(command, 7);
    const void* data = gl_param_data(command, 8);
    real(target, level, internalFormat, width, height, border, format, type, data);
    replay_get_tex_params(ctx, inspect_command, target);
    replay_get_tex_data(ctx, inspect_command, target, level);

glTexParameterf:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    GLfloat param = gl_param_GLfloat(command, 2);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameteri:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    GLint param = gl_param_GLint(command, 2);
    real(target, pname, param);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameterfv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = &trace_get_arg(command, 2)->val;
    GLfloat params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_double(params_val)[i];
    
    real(target, pname, params);
    replay_get_tex_params(ctx, inspect_command, target);

glTexParameteriv:
    GLenum target = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = &trace_get_arg(command, 2)->val;
    GLint params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_int(params_val)[i];
    
    real(target, pname, params);
    replay_get_tex_params(ctx, inspect_command, target);

glGenBuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    real(n, buffers);
    
    for (size_t i = 0; i < n; ++i) {
        replay_create_object(ctx, ReplayObjType_GLBuffer, buffers[i], fake[i]);
        
        inspect_action_t action;
        action.type = InspectAction_GenBuffer;
        action.buffer = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }

glDeleteBuffers:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint buffers[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; ++i) {
        if (!(buffers[i] = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake[i])))
            inspect_add_error(inspect_command, "Invalid buffer being deleted.");
        
        inspect_action_t action;
        action.type = InspectAction_DelBuffer;
        action.buffer = fake[i];
        append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);
    }
    
    real(n, buffers);

glBindBuffer:
    GLuint target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint real_buf = replay_get_real_object(ctx, ReplayObjType_GLBuffer, fake);
    if (!real_buf)
        inspect_add_error(inspect_command, "Invalid buffer being bound.");
    real(target, real_buf);

glBufferData:
    GLuint target = gl_param_GLenum(command, 0);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 1);
    const void* data = gl_param_data(command, 2);
    GLenum usage = gl_param_GLenum(command, 3);
    real(target, size, data, usage);
    
    inspect_action_t action;
    action.type = InspectAction_BufferData;
    action.buf_data.buffer = get_bound_buffer(ctx, target);
    action.buf_data.size = size;
    action.buf_data.data = malloc(size);
    memcpy(action.buf_data.data, data, size);
    action.buf_data.usage = usage;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glBufferSubData:
    GLuint target = gl_param_GLenum(command, 0);
    GLintptr offset = gl_param_GLintptr(command, 1);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 2);
    const void* data = gl_param_data(command, 3);
    real(target, offset, size, data);
    
    inspect_action_t action;
    action.type = InspectAction_BufferSubData;
    action.buf_sub_data.buffer = get_bound_buffer(ctx, target);
    action.buf_sub_data.offset = offset;
    action.buf_sub_data.size = size;
    action.buf_sub_data.data = malloc(size);
    memcpy(action.buf_sub_data.data, data, size);
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glMappedBufferDataWIP15:
    GLuint target = gl_param_GLenum(command, 0);
    GLsizeiptr size = gl_param_GLsizeiptr(command, 1);
    const void* data = gl_param_data(command, 2);
    F(glBufferSubData)(target, 0, size, data);
    
    inspect_action_t action;
    action.type = InspectAction_BufferSubData;
    action.buf_sub_data.buffer = get_bound_buffer(ctx, target);
    action.buf_sub_data.offset = 0;
    action.buf_sub_data.size = size;
    action.buf_sub_data.data = malloc(size);
    memcpy(action.buf_sub_data.data, data, size);
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glLoadMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glLoadMatrixf:
    F(glLoadMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glLoadTransposeMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glLoadTransposeMatrixf:
    F(glLoadTransposeMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glMultMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glMultMatrixf:
    F(glMultMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glMultTransposeMatrixd:
    real(trace_get_double(&trace_get_arg(command, 0)->val));

glMultTransposeMatrixf:
    F(glMultTransposeMatrixd)(trace_get_double(&trace_get_arg(command, 0)->val));

glCreateShader:
    GLenum type = gl_param_GLenum(command, 0);
    GLuint real_shdr = F(glCreateShader)(type);
    GLuint fake = trace_get_uint(&command->ret)[0];
    replay_create_object(ctx, ReplayObjType_GLShader, real_shdr, fake);
    
    inspect_action_t action;
    action.type = InspectAction_NewShader;
    action.new_shader.type = type;
    action.new_shader.shader = fake;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glDeleteShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    F(glDeleteShader)(real_shdr);
    
    replay_destroy_object(ctx, ReplayObjType_GLShader, fake);
    
    inspect_action_t action;
    action.type = InspectAction_DelShader;
    action.del_shader = fake;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glShaderSource:
    GLuint fake = gl_param_GLuint(command, 0);
    GLsizei count = gl_param_GLsizei(command, 1);
    char** sources = gl_param_string_array(command, 2);
    
    GLuint shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    inspect_action_t action;
    action.type = InspectAction_ShaderSource;
    action.shader_source.shader = fake;
    action.shader_source.count = count;
    action.shader_source.sources = malloc(sizeof(char*)*count);
    
    if (trace_get_arg(command, 3)->val.count == 0) {
        real(shader, 1, (const GLchar*const*)sources, NULL);
        
        for (GLsizei i = 0; i < count; i++) {
            size_t len = strlen(sources[i]);
            action.shader_source.sources[i] = malloc(len+1);
            memcpy(action.shader_source.sources[i], sources[i], len);
            action.shader_source.sources[i][len] = 0;
        }
    } else {
        uint64_t* lengths64 = trace_get_uint(&trace_get_arg(command, 3)->val);
        
        GLint lengths[count];
        for (GLsizei i = 0; i < count; i++) {
            lengths[i] = lengths64[i];
        }
        
        real(shader, count, (const GLchar*const*)sources, lengths);
        
        for (GLsizei i = 0; i < count; i++) {
            action.shader_source.sources[i] = malloc(lengths[i]+1);
            memcpy(action.shader_source.sources[i], sources[i], lengths[i]);
            action.shader_source.sources[i][lengths[i]] = 0;
        }
    }
    
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glCompileShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    real(real_shdr);
    
    GLint status;
    F(glGetShaderiv)(real_shdr, GL_COMPILE_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Unable to compile shader.");
    
    GLint len;
    F(glGetShaderiv)(real_shdr, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetShaderInfoLog)(real_shdr, len, NULL, info_log);
    
    inspect_action_t action;
    action.type = InspectAction_UpdateShdrInfoLog;
    action.info_log.obj = fake;
    action.info_log.str = info_log;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glCreateProgram:
    GLuint real_program = F(glCreateProgram)();
    GLuint fake = trace_get_uint(&command->ret)[0];
    replay_create_object(ctx, ReplayObjType_GLProgram, real_program, fake);
    
    inspect_action_t action;
    action.type = InspectAction_NewProgram;
    action.program = fake;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glDeleteProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);
    
    replay_destroy_object(ctx, ReplayObjType_GLProgram, fake);
    
    inspect_action_t action;
    action.type = InspectAction_DelProgram;
    action.program = fake;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glAttachShader:
    GLuint fake_program = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_program);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    GLuint fake_shader = gl_param_GLuint(command, 1);
    GLuint real_shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake_shader);
    if (!real_shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    real(real_program, real_shader);
    
    inspect_action_t action;
    action.type = InspectAction_AttachShader;
    action.prog_shdr.program = fake_program;
    action.prog_shdr.shader = fake_shader;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glDetachShader:
    GLuint fake_program = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_program);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    GLuint fake_shader = gl_param_GLuint(command, 1);
    GLuint real_shader = replay_get_real_object(ctx, ReplayObjType_GLShader, fake_shader);
    if (!real_shader) {
        inspect_add_error(inspect_command, "Invalid shader.");
        return;
    }
    
    real(real_program, real_shader);
    
    inspect_action_t action;
    action.type = InspectAction_DetachShader;
    action.prog_shdr.program = fake_program;
    action.prog_shdr.shader = fake_shader;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glLinkProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);
    
    GLint status;
    F(glGetProgramiv)(real_program, GL_LINK_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Unable to link program.");
    
    GLint len;
    F(glGetProgramiv)(real_program, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetProgramInfoLog)(real_program, len, NULL, info_log);
    
    inspect_action_t action;
    action.type = InspectAction_UpdateProgramInfoLog;
    action.info_log.obj = fake;
    action.info_log.str = info_log;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glValidateProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);
    
    GLint status;
    F(glGetProgramiv)(real_program, GL_LINK_STATUS, &status);
    if (!status)
        inspect_add_error(inspect_command, "Program validation failed.");
    
    GLint len;
    F(glGetProgramiv)(real_program, GL_INFO_LOG_LENGTH, &len);
    char* info_log = malloc(len+1);
    info_log[len] = 0;
    F(glGetProgramInfoLog)(real_program, len, NULL, info_log);
    
    inspect_action_t action;
    action.type = InspectAction_UpdateProgramInfoLog;
    action.info_log.obj = fake;
    action.info_log.str = info_log;
    append_vec(inspect_command->state.actions, sizeof(inspect_action_t), &action);

glUseProgram:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(real_program);

glIsBuffer:
    ;

glIsList:
    ;

glIsProgram:
    ;

glIsQuery:
    ;

glIsShader:
    ;

glIsTexture:
    ;

glRectd:
    GLdouble x1 = gl_param_GLdouble(command, 0);
    GLdouble y1 = gl_param_GLdouble(command, 1);
    GLdouble x2 = gl_param_GLdouble(command, 2);
    GLdouble y2 = gl_param_GLdouble(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glRectf:
    GLfloat x1 = gl_param_GLfloat(command, 0);
    GLfloat y1 = gl_param_GLfloat(command, 1);
    GLfloat x2 = gl_param_GLfloat(command, 2);
    GLfloat y2 = gl_param_GLfloat(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glRecti:
    GLint x1 = gl_param_GLint(command, 0);
    GLint y1 = gl_param_GLint(command, 1);
    GLint x2 = gl_param_GLint(command, 2);
    GLint y2 = gl_param_GLint(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glRects:
    GLshort x1 = gl_param_GLshort(command, 0);
    GLshort y1 = gl_param_GLshort(command, 1);
    GLshort x2 = gl_param_GLshort(command, 2);
    GLshort y2 = gl_param_GLshort(command, 3);
    real(x1, y1, x2, y2);
    replay_get_back_color(ctx, inspect_command);
    replay_get_depth(ctx, inspect_command);

glAreTexturesResident:
    ;

glPrioritizeTextures:
    GLsizei n = gl_param_GLsizei(command, 0);
    
    GLuint textures[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; i++)
        if (!(textures[i] = replay_get_real_object(ctx, ReplayObjType_GLTexture, fake[i])))
            inspect_add_error(inspect_command, "Invalid texture at %zu.", i);
    
    float priorities[n];
    for (size_t i = 0; i < n; i++)
        priorities[i] = trace_get_double(&trace_get_arg(command, 2)->val)[i];
    
    real(n, textures, priorities);

glBindAttribLocation:
    GLuint fake_prog = gl_param_GLuint(command, 0);
    GLuint index = gl_param_GLuint(command, 1);
    const GLchar* name = gl_param_string(command, 2);
    
    GLuint program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake_prog);
    if (!program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    
    real(program, index, name);

glBeginQuery:
    GLenum target = gl_param_GLenum(command, 0);
    GLuint fake = gl_param_GLuint(command, 1);
    GLuint id = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake);
    real(target, id);

glGenLists:
    GLsizei range = gl_param_GLsizei(command, 0);
    GLuint fake = *trace_get_uint(&command->ret);
    GLuint real_lists = real(range);
    if (!real_lists) {
        inspect_add_error(inspect_command, "Unable to create lists.");
        return;
    }
    
    for (GLsizei i = 0; i < range; i++)
        replay_create_object(ctx, ReplayObjType_GLDisplayList, real_lists+i, fake+i);

glNewList:
    GLuint fake = gl_param_GLuint(command, 0);
    GLenum mode = gl_param_GLenum(command, 1);
    
    GLuint list = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, fake);
    if (!list) {
        inspect_add_error(inspect_command, "Invalid display list.");
        return;
    }
    
    real(list, mode);

glGenQueries:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint queries[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    real(n, queries);
    
    for (size_t i = 0; i < n; ++i)
        replay_create_object(ctx, ReplayObjType_GLQuery, queries[i], fake[i]);

glDeleteQueries:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLuint queries[n];
    uint64_t* fake = trace_get_uint(&trace_get_arg(command, 1)->val);
    
    for (size_t i = 0; i < n; ++i)
        if (!(queries[i] = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake[i])))
            inspect_add_error(inspect_command, "Invalid query being deleted.");
    
    real(n, queries);

glDeleteLists:
    GLuint fake = gl_param_GLuint(command, 0);
    GLsizei range = gl_param_GLsizei(command, 1);
    
    GLuint list = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, fake);
    if (!list) {
        inspect_add_error(inspect_command, "Invalid display list.");
        return;
    }
    
    real(list, range);

glCallList:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint list = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, fake);
    if (!list) {
        inspect_add_error(inspect_command, "Invalid display list.");
        return;
    }
    
    real(list);

glGetUniformfv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glGetUniformiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glGetAttribLocation:
    GLuint fake = gl_param_GLuint(command, 0);
    const GLchar* name = gl_param_string(command, 1);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    if (real(real_program, name) < 0)
        inspect_add_error(inspect_command, "No such attribute \"%s\".", name);

glGetUniformLocation:
    GLuint fake = gl_param_GLuint(command, 0);
    const GLchar* name = gl_param_string(command, 1);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program) {
        inspect_add_error(inspect_command, "Invalid program.");
        return;
    }
    if (real(real_program, name) < 0)
        inspect_add_error(inspect_command, "No such uniform \"%s\".", name);

glGetShader:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr)
        inspect_add_error(inspect_command, "Invalid shader.");

glGetShaderInfoLog:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr)
        inspect_add_error(inspect_command, "Invalid shader.");

glGetShaderSource:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_shdr = replay_get_real_object(ctx, ReplayObjType_GLShader, fake);
    if (!real_shdr)
        inspect_add_error(inspect_command, "Invalid shader.");

glGetQueryiv:
    ;

glGetQueryObjectiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_query = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake);
    if (!real_query)
        inspect_add_error(inspect_command, "Invalid query.");

glGetQueryObjectuiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_query = replay_get_real_object(ctx, ReplayObjType_GLQuery, fake);
    if (!real_query)
        inspect_add_error(inspect_command, "Invalid query.");

glGetProgramInfoLog:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_prog = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_prog)
        inspect_add_error(inspect_command, "Invalid program.");

glGetProgramiv:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_prog = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_prog)
        inspect_add_error(inspect_command, "Invalid program.");

glGetLightfv:
    ;

glGetLightfiv:
    ;

glGetMaterialfv:
    ;

glGetMaterialiv:
    ;

glGetMapdv:
    ;

glGetMapfv:
    ;

glGetMapiv:
    ;

glGetHistogram:
    ;

glGetHistogramParameterfv:
    ;

glGetHistogramParameteriv:
    ;

glGetConvolutionFilter:
    ;

glGetConvolutionParameterfv:
    ;

glGetConvolutionParameteriv:
    ;

glGetClipPlane:
    ;

glGetTexEnvfv:
    ;

glGetTexEnviv:
    ;

glGetTexGendv:
    ;

glGetTexGenfv:
    ;

glGetTexGeniv:
    ;

glGetTexLevelParameterfv:
    ;

glGetTexLevelParameteriv:
    ;

glGetTexParameterfv:
    ;

glGetTexParameteriv:
    ;

glGetPointerv:
    ;

glGetPolygonStipple:
    ;

glGetMinmax:
    ;

glGetMinmaxParameterfv:
    ;

glGetMinmaxParameteriv:
    ;

glGetPixelMapfv:
    ;

glGetPixelMapuiv:
    ;

glGetPixelMapusv:
    ;

glGetSeparableFilter:
    ;

glGetBufferParameteriv:
    ;

glGetBufferPointerv:
    ;

glGetBufferSubData:
    ;

glGetTexImage:
    ;

glGetBooleanv:
    ;

glGetDoublev:
    ;

glGetFloatv:
    ;

glGetIntegerv:
    ;

glGetVertexAttribdv:
    ;

glGetVertexAttrivfv:
    ;

glGetVertexAttribiv:
    ;

glGetVertexAttribPointerv:
    ;

glGetCompressedTexImage:
    ;

glGetColorTableParameterfv:
    ;

glGetColorTableParameteriv:
    ;

glGetColorTable:
    ;

glGetAttachedShaders:
    ;

glGetActiveUniform:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glGetActiveAttrib:
    GLuint fake = gl_param_GLuint(command, 0);
    GLuint real_program = replay_get_real_object(ctx, ReplayObjType_GLProgram, fake);
    if (!real_program)
        inspect_add_error(inspect_command, "Invalid program.");

glCallLists:
    GLsizei n = gl_param_GLsizei(command, 0);
    GLenum type = gl_param_GLenum(command, 1);
    void* lists = gl_param_data(command, 2);
    
    int64_t real_lists[n];
    for (GLsizei i = 0; i < n; i++) {
        switch (type) {
        case GL_BYTE:
            real_lists[i] = ((int8_t*)lists)[i];
            break;
        case GL_UNSIGNED_BYTE:
            real_lists[i] = ((uint8_t*)lists)[i];
            break;
        case GL_SHORT:
            real_lists[i] = ((int16_t*)lists)[i];
            break;
        case GL_UNSIGNED_SHORT:
            real_lists[i] = ((uint16_t*)lists)[i];
            break;
        case GL_INT:
            real_lists[i] = ((int32_t*)lists)[i];
            break;
        case GL_UNSIGNED_INT:
            real_lists[i] = ((uint32_t*)lists)[i];
            break;
        case GL_FLOAT:
            real_lists[i] = ((float*)lists)[i];
            break;
        case GL_2_BYTES:
            real_lists[i] = ((uint8_t*)lists)[i*2]*256 +
                            ((uint8_t*)lists)[i*2+1];
            break;
        case GL_3_BYTES:
            real_lists[i] = ((uint8_t*)lists)[i*3]*65536u +
                            ((uint8_t*)lists)[i*3+1]*256u +
                            ((uint8_t*)lists)[i*3+2];
            break;
        case GL_4_BYTES:
            real_lists[i] = ((uint8_t*)lists)[i*3]*16777216u +
                            ((uint8_t*)lists)[i*3+1]*65536u +
                            ((uint8_t*)lists)[i*3+2]*256u +
                            ((uint8_t*)lists)[i*3+3];
            break;
        default:
            inspect_add_error(inspect_command, "Invalid type.");
            return;
        }
    }
    
    GLint base;
    F(glGetIntegerv)(GL_LIST_BASE, &base);
    
    GLuint gl_lists[n];
    for (GLsizei i = 0; i < n; i++) {
        real_lists[i] += base;
        GLuint real = replay_get_real_object(ctx, ReplayObjType_GLDisplayList, real_lists[i]);
        if ((real_lists[i] < 0) || !real) {
            inspect_add_error(inspect_command, "Invalid display list at %d.\n", (int)i);
            return;
        }
        gl_lists[i] = real;
    }
    
    real(n, GL_UNSIGNED_INT, gl_lists);

glReadPixels:
    ;

glLightModelfv:
    GLenum pname = gl_param_GLenum(command, 0);
    
    trace_value_t* params_val = &trace_get_arg(command, 1)->val;
    GLfloat params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_double(params_val)[i];
    
    real(pname, params);

glLightModeliv:
    GLenum pname = gl_param_GLenum(command, 0);
    
    trace_value_t* params_val = &trace_get_arg(command, 1)->val;
    GLint params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_int(params_val)[i];
    
    real(pname, params);

glLightfv:
    GLenum light = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = &trace_get_arg(command, 2)->val;
    GLfloat params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_double(params_val)[i];
    
    real(light, pname, params);

glLightiv:
    GLenum light = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = &trace_get_arg(command, 2)->val;
    GLint params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_int(params_val)[i];
    
    real(light, pname, params);

glMaterialfv:
    GLenum face = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = &trace_get_arg(command, 2)->val;
    GLfloat params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_double(params_val)[i];
    
    real(face, pname, params);

glMaterialiv:
    GLenum face = gl_param_GLenum(command, 0);
    GLenum pname = gl_param_GLenum(command, 1);
    
    trace_value_t* params_val = &trace_get_arg(command, 2)->val;
    GLint params[params_val->count];
    for (size_t i = 0; i < params_val->count; i++)
        params[i] = trace_get_int(params_val)[i];
    
    real(face, pname, params);

glNormal3bv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glNormal3b)(v[0], v[1], v[2]);

glNormal3dv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glNormal3d)(v[0], v[1], v[2]);

glNormal3fv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glNormal3f)(v[0], v[1], v[2]);

glNormal3iv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glNormal3i)(v[0], v[1], v[2]);

glNormal3sv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glNormal3s)(v[0], v[1], v[2]);

glVertex2sv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glVertex2s)(v[0], v[1]);

glVertex2iv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glVertex2i)(v[0], v[1]);

glVertex2fv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glVertex2f)(v[0], v[1]);

glVertex2dv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glVertex2d)(v[0], v[1]);

glVertex3sv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glVertex3s)(v[0], v[1], v[2]);

glVertex3iv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glVertex3i)(v[0], v[1], v[2]);

glVertex3fv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glVertex3f)(v[0], v[1], v[2]);

glVertex3dv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glVertex3d)(v[0], v[1], v[2]);

glVertex4sv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glVertex4s)(v[0], v[1], v[2], v[3]);

glVertex4iv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glVertex4i)(v[0], v[1], v[2], v[3]);

glVertex4fv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glVertex4f)(v[0], v[1], v[2], v[3]);

glVertex4dv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glVertex4d)(v[0], v[1], v[2], v[3]);

glTexCoord1sv:
    F(glTexCoord1s)(gl_param_GLshort(command, 0));

glTexCoord1iv:
    F(glTexCoord1i)(gl_param_GLint(command, 0));

glTexCoord1fv:
    F(glTexCoord1f)(gl_param_GLfloat(command, 0));

glTexCoord1dv:
    F(glTexCoord1d)(gl_param_GLdouble(command, 0));

glTexCoord2sv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glTexCoord2s(v[0], v[1]));

glTexCoord2iv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glTexCoord2i(v[0], v[1]));

glTexCoord2fv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glTexCoord2f(v[0], v[1]));

glTexCoord2dv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glTexCoord2d(v[0], v[1]));

glTexCoord3sv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glTexCoord3s(v[0], v[1], v[2]));

glTexCoord3iv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glTexCoord3i(v[0], v[1], v[2]));

glTexCoord3fv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glTexCoord3f(v[0], v[1], v[2]));

glTexCoord3dv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glTexCoord3d(v[0], v[1], v[2]));

glTexCoord4sv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glTexCoord4s(v[0], v[1], v[2], v[3]));

glTexCoord4iv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glTexCoord4i(v[0], v[1], v[2], v[3]));

glTexCoord4fv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glTexCoord4f(v[0], v[1], v[2], v[3]));

glTexCoord4dv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glTexCoord4d(v[0], v[1], v[2], v[3]));

glIndexsv:
    F(glIndexs)(gl_param_GLshort(command, 0));

glIndexiv:
    F(glIndexi)(gl_param_GLint(command, 0));

glIndexfv:
    F(glIndexf)(gl_param_GLfloat(command, 0));

glIndexdv:
    F(glIndexd)(gl_param_GLdouble(command, 0));

glIndexubv:
    F(glIndexub)(gl_param_GLubyte(command, 0));

glFogCoorddv:
    F(glFogCoordd)(gl_param_GLdouble(command, 0));

glFogCoordfv:
    F(glFogCoordf)(gl_param_GLfloat(command, 0));

glEdgeFlagv:
    F(glEdgeFlag)(gl_param_GLboolean(command, 0));

glColor3bv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor3b)(v[0], v[1], v[2]);

glColor3sv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor3s)(v[0], v[1], v[2]);

glColor3iv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor3i)(v[0], v[1], v[2]);

glColor3fv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glColor3f)(v[0], v[1], v[2]);

glColor3dv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glColor3d)(v[0], v[1], v[2]);

glColor3ubv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor3ub)(v[0], v[1], v[2]);

glColor3usv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor3us)(v[0], v[1], v[2]);

glColor3uiv:
    uint64_t* v = trace_get_uint(&trace_get_arg(command, 0)->val);
    F(glColor3ui)(v[0], v[1], v[2]);

glColor4bv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor4b)(v[0], v[1], v[2], v[3]);

glColor4sv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor4s)(v[0], v[1], v[2], v[3]);

glColor4iv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor4i)(v[0], v[1], v[2], v[3]);

glColor4fv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glColor4f)(v[0], v[1], v[2], v[3]);

glColor4dv:
    double* v = trace_get_double(&trace_get_arg(command, 0)->val);
    F(glColor4d)(v[0], v[1], v[2], v[3]);

glColor4ubv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor4ub)(v[0], v[1], v[2], v[3]);

glColor4usv:
    int64_t* v = trace_get_int(&trace_get_arg(command, 0)->val);
    F(glColor4us)(v[0], v[1], v[2], v[3]);

glColor4uiv:
    uint64_t* v = trace_get_uint(&trace_get_arg(command, 0)->val);
    F(glColor4ui)(v[0], v[1], v[2], v[3]);

glRectdv:
    double *v1 = trace_get_double(&trace_get_arg(command, 0)->val);
    double *v2 = trace_get_double(&trace_get_arg(command, 1)->val);
    F(glRectd)(v1[0], v1[1], v2[0], v2[1]);

glRectfv:
    double *v1 = trace_get_double(&trace_get_arg(command, 0)->val);
    double *v2 = trace_get_double(&trace_get_arg(command, 1)->val);
    F(glRectf)(v1[0], v1[1], v2[0], v2[1]);

glRectiv:
    int64_t *v1 = trace_get_int(&trace_get_arg(command, 0)->val);
    int64_t *v2 = trace_get_int(&trace_get_arg(command, 1)->val);
    F(glRecti)(v1[0], v1[1], v2[0], v2[1]);

glRectsv:
    int64_t *v1 = trace_get_int(&trace_get_arg(command, 0)->val);
    int64_t *v2 = trace_get_int(&trace_get_arg(command, 1)->val);
    F(glRects)(v1[0], v1[1], v2[0], v2[1]);
