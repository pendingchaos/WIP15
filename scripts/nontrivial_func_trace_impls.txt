glXChooseVisual: pointer, pointer, int, GLint+array
    gl_param_pointer(dpy);
    gl_param_int(screen);
    size_t count = 0;
    while (attribList[count]) count += 2;
    gl_param_GLint_array(count+1, attribList);
    XVisualInfo* result = gl_glXChooseVisual(dpy, screen, attribList);
    gl_result_pointer(result);

glXMakeCurrent: Bool, pointer, GLXDrawable, GLXContext
    gl_param_pointer(dpy);
    gl_param_GLXDrawable(drawable);
    gl_param_GLXContext(ctx);
    Bool result = gl_glXMakeCurrent(dpy, drawable, ctx);
    gl_result_Bool(result);
    if (!ctx) {
        current_limits = NULL;
    } else {
        current_limits = &gl30_limits; //TODO
    }
    reset_gl();

glXCreateContextAttribsARB: GLXContext, pointer, GLXFBConfig, GLXContext, Bool, GLint+array
    gl_param_pointer(dpy);
    gl_param_GLXFBConfig(config);
    gl_param_GLXContext(share_context);
    gl_param_Bool(direct);
    size_t count = 0;
    while (attrib_list[count]) count += 2;
    gl_param_GLint_array(count+1, attrib_list);
    GLXContext result = gl_glXCreateContextAttribsARB(dpy, config, share_context, direct, attrib_list);
    gl_result_GLXContext(result);

glSetContextCapsWIP15: void
    //TODO
    /*gl_write_b(WIP15_DATA);
    gl_write_u32(0*sizeof(uint32_t));
    #define LIMIT(pname) gl_write_u32(*gl_geti(GL_##pname));
    //TODO: Make LIMITF more portable
    #define LIMITF(pname) fwrite(gl_getf(GL_##pname), 4, 1, trace_file);
    //TODO: *bits_supported
    #undef LIMITF
    #undef LIMIT*/

glGenTextures: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_glGenTextures(n, textures);
    gl_param_GLuint_array(n, textures);

glDeleteTextures: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_param_GLuint_array(n, textures);
    gl_glDeleteTextures(n, textures);

glTexImage1D: void, GLenum+group, GLint, GLint, GLsizei, GLint, GLenum, GLenum+group, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLint(internalformat); //TODO: The group
    gl_param_GLsizei(width);
    gl_param_GLint(border);
    gl_param_GLenum(format); //TODO: The group
    gl_param_GLenum(type);
    gl_write_group(GROUP_PixelType);
    
    size_t texel_size = get_texel_size(format, type);
    if (pixels) {
        gl_param_data(width*texel_size, pixels);
    } else {
        void* data = malloc(width*texel_size);
        gl_param_data(width*texel_size, data);
        free(data);
    }
    
    gl_glTexImage1D(target, level, internalformat, width, border, format, type, pixels);

glTexSubImage1D: void, GLenum+group, GLint, GLint, GLsizei, GLenum, GLenum+group, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLint(xoffset);
    gl_param_GLsizei(width);
    gl_param_GLenum(format); //TODO: The group
    gl_param_GLenum(type);
    gl_write_group(GROUP_PixelType);
    
    size_t texel_size = get_texel_size(format, type);
    if (pixels) {
        gl_param_data(width*texel_size, pixels);
    } else {
        void* data = malloc(width*texel_size);
        gl_param_data(width*texel_size, data);
        free(data);
    }
    
    gl_glTexSubImage1D(target, level, xoffset, width, format, type, pixels);

glTexImage2D: void, GLenum+group, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum+group, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLint(internalformat); //TODO: The group
    gl_param_GLsizei(width);
    gl_param_GLsizei(height);
    gl_param_GLint(border);
    gl_param_GLenum(format);
    gl_param_GLenum(type);
    gl_write_group(GROUP_PixelType);
    
    size_t texel_size = get_texel_size(format, type);
    if (pixels) {
        gl_param_data(width*height*texel_size, pixels);
    } else {
        void* data = malloc(width*height*texel_size);
        gl_param_data(width*height*texel_size, data);
        free(data);
    }
    
    gl_glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);

glTexSubImage2D: void, GLenum+group, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum+group, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLint(xoffset);
    gl_param_GLint(yoffset);
    gl_param_GLsizei(width);
    gl_param_GLsizei(height);
    gl_param_GLenum(format); //TODO: The group
    gl_param_GLenum(type);
    gl_write_group(GROUP_PixelType);
    
    size_t texel_size = get_texel_size(format, type);
    if (pixels) {
        gl_param_data(width*height*texel_size, pixels);
    } else {
        void* data = malloc(width*height*texel_size);
        gl_param_data(width*height*texel_size, data);
        free(data);
    }
    
    gl_glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);

glTexImage3D: void, GLenum+group, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLint(internalformat);
    gl_param_GLsizei(width);
    gl_param_GLsizei(height);
    gl_param_GLsizei(depth);
    gl_param_GLint(border);
    gl_param_GLenum(format);
    gl_param_GLenum(type);
    
    size_t texel_size = get_texel_size(format, type);
    if (pixels) {
        gl_param_data(width*height*depth*texel_size, pixels);
    } else {
        void* data = malloc(width*height*depth*texel_size);
        gl_param_data(width*height*depth*texel_size, data);
        free(data);
    }
    
    gl_glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);

glTexSubImage3D: void, GLenum+group, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLint(xoffset);
    gl_param_GLint(yoffset);
    gl_param_GLint(zoffset);
    gl_param_GLsizei(width);
    gl_param_GLsizei(height);
    gl_param_GLsizei(depth);
    gl_param_GLenum(format);
    gl_param_GLenum(type);
    
    size_t texel_size = get_texel_size(format, type);
    if (pixels) {
        gl_param_data(width*height*depth*texel_size, pixels);
    } else {
        void* data = malloc(width*height*depth*texel_size);
        gl_param_data(width*height*depth*texel_size, data);
        free(data);
    }
    
    gl_glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);

glCompressedTexImage1D: void, GLenum+group, GLint, GLenum, GLsizei, GLint, GLsizei, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLenum(internalformat); //TODO: The group
    gl_param_GLsizei(width);
    gl_param_GLint(border);
    gl_param_GLsizei(imageSize);
    gl_param_data(imageSize, data);
    gl_glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);

glCompressedTexSubImage1D: void, GLenum+group, GLint, GLint, GLsizei, GLenum, GLsizei, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLint(xoffset);
    gl_param_GLsizei(width);
    gl_param_GLenum(format); //TODO: The group
    gl_param_GLsizei(imageSize);
    gl_param_data(imageSize, data);
    gl_glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);

glCompressedTexImage2D: void, GLenum+group, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLenum(internalformat); //TODO: The group
    gl_param_GLsizei(width);
    gl_param_GLsizei(height);
    gl_param_GLint(border);
    gl_param_GLsizei(imageSize);
    gl_param_data(imageSize, data);
    gl_glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);

glCompressedTexSubImage2D: void, GLenum+group, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLint(xoffset);
    gl_param_GLint(yoffset);
    gl_param_GLsizei(width);
    gl_param_GLsizei(height);
    gl_param_GLenum(format); //TODO: The group
    gl_param_GLsizei(imageSize);
    gl_param_data(imageSize, data);
    gl_glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);

glCompressedTexImage3D: void, GLenum+group, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLenum(internalformat); //TODO: The group
    gl_param_GLsizei(width);
    gl_param_GLsizei(height);
    gl_param_GLsizei(depth);
    gl_param_GLint(border);
    gl_param_GLsizei(imageSize);
    gl_param_data(imageSize, data);
    gl_glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);

glCompressedTexSubImage3D: void, GLenum+group, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, data
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLint(level);
    gl_param_GLint(xoffset);
    gl_param_GLint(yoffset);
    gl_param_GLint(zoffset);
    gl_param_GLsizei(width);
    gl_param_GLsizei(height);
    gl_param_GLsizei(depth);
    gl_param_GLenum(format); //TODO: The group
    gl_param_GLsizei(imageSize);
    gl_param_data(imageSize, data);
    gl_glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);

glGenBuffers: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_glGenBuffers(n, buffers);
    gl_param_GLuint_array(n, buffers);

glDeleteBuffers: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_param_GLuint_array(n, buffers);
    gl_glDeleteBuffers(n, buffers);

glBufferData: void, GLenum, GLsizeiptr, data, GLenum
    gl_param_GLenum(target); //TODO: The group
    gl_param_GLsizeiptr(size);
    
    if (data) {
        gl_param_data(size, data);
    } else {
        void* ptr = malloc(size);
        gl_param_data(size, ptr);
        free(ptr);
    }
    
    gl_param_GLenum(usage); //TODO: The group
    
    gl_glBufferData(target, size, data, usage);

glBufferSubData: void, GLenum, GLintptr, GLsizeiptr, data
    gl_param_GLenum(target); //TODO: The group
    gl_param_GLintptr(offset);
    gl_param_GLsizeiptr(size);
    gl_param_data(size, data);
    
    gl_glBufferSubData(target, offset, size, data);

glUnmapBuffer: GLboolean, GLenum
    gl_param_GLenum(target); //TODO: The group
    
    GLboolean result = gl_glUnmapBuffer(target);
    gl_result_GLboolean(result);
    
    GLint access;
    F(glGetBufferParameteriv)(target, GL_BUFFER_ACCESS, &access);
    if (access != GL_READ_ONLY) {
        GLint size;
        F(glGetBufferParameteriv)(target, GL_BUFFER_SIZE, &size);
        
        void* data = malloc(size);
        F(glGetBufferSubData)(target, 0, size, data);
        gl_add_extra("replay/glUnmapBuffer/data", size, data);
        free(data);
    }

glShaderSource: void, GLuint, GLsizei, string+array, GLint+array
    gl_param_GLuint(shader);
    gl_param_GLsizei(count);
    if (length) {
        GLchar* sources[count];
        
        for (GLsizei i = 0; i < count; i++) {
            sources[i] = malloc(length[i]+1);
            memcpy(sources[i], string[i], length[i]);
            sources[i][length[i]] = 0;
        }
        
        gl_param_string_array((const GLchar*const*)sources, count);
        
        for (GLsizei i = 0; i < count; i++)
            free(sources[i]);
        
        gl_param_GLint_array(count, (GLint*)length);
    } else {
        gl_param_string_array(string, count);
        gl_param_GLint_array(0, NULL);
    }
    gl_glShaderSource(shader, count, string, length);

glGetBooleanv: void, GLenum+group, pointer
    gl_param_GLenum(pname);
    gl_write_group(GROUP_GetPName);
    gl_param_pointer(data);
    GL_GET(glGetBooleanv)

glGetDoublev: void, GLenum+group, pointer
    gl_param_GLenum(pname);
    gl_write_group(GROUP_GetPName);
    gl_param_pointer(data);
    GL_GET(glGetDoublev)

glGetFloatv: void, GLenum+group, pointer
    gl_param_GLenum(pname);
    gl_write_group(GROUP_GetPName);
    gl_param_pointer(data);
    GL_GET(glGetFloatv)

glGetIntegerv: void, GLenum+group, pointer
    gl_param_GLenum(pname);
    gl_write_group(GROUP_GetPName);
    gl_param_pointer(data);
    GL_GET(glGetIntegerv)

glGetString: string, GLenum+group
    gl_param_GLenum(name);
    gl_write_group(GROUP_StringName);
    const GLubyte* result = (const GLubyte*)"";
    //TODO: Hack to get glfw 3.0.3 working
    #if 0
    switch (name) {
    case GL_VENDOR:
        if (current_limits->vendor.exists)
            result = current_limits->vendor.str;
        else
            result = gl_glGetString(GL_VENDOR);
        break;
    case GL_RENDERER:
        if (current_limits->renderer.exists)
            result = current_limits->renderer.str;
        else
            result = gl_glGetString(GL_RENDERER);
        break;
    case GL_VERSION:
        if (current_limits->version.exists)
            result = current_limits->version.str;
        else
            result = gl_glGetString(GL_VERSION);
        break;
    case GL_SHADING_LANGUAGE_VERSION:
        if (current_limits->shading_language_version.exists)
            result = current_limits->shading_language_version.str;
        else
            result = gl_glGetString(GL_SHADING_LANGUAGE_VERSION);
        break;
    case GL_EXTENSIONS:
        if (current_limits->extensions.exists)
            result = current_limits->extensions_str;
        else
            result = gl_glGetString(GL_EXTENSIONS);
        break;
    }
    #else
    result = gl_glGetString(name);
    #endif
    
    gl_result_string((const char*)result);

glTexParameterfv: void, GLenum+group, GLenum+group, GLfloat+array
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLenum(pname);
    gl_write_group(GROUP_TextureParameterName);
    
    if (pname == GL_TEXTURE_BORDER_COLOR)
        gl_param_GLfloat_array(4, params);
    else
        gl_param_GLfloat_array(1, params);
    
    gl_glTexParameterfv(target, pname, params);

glTexParameteriv: void, GLenum+group, GLenum+group, GLint+array
    gl_param_GLenum(target);
    gl_write_group(GROUP_TextureTarget);
    gl_param_GLenum(pname);
    gl_write_group(GROUP_TextureParameterName);
    
    if (pname == GL_TEXTURE_BORDER_COLOR)
        gl_param_GLint_array(4, params);
    else
        gl_param_GLint_array(1, params);
    
    gl_glTexParameteriv(target, pname, params);

glUniform1fv: void, GLint, GLsizei, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLfloat_array(count, value);
    gl_glUniform1fv(location, count, value);

glUniform2fv: void, GLint, GLsizei, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLfloat_array(count*2, value);
    gl_glUniform2fv(location, count, value);

glUniform3fv: void, GLint, GLsizei, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLfloat_array(count*3, value);
    gl_glUniform3fv(location, count, value);

glUniform4fv: void, GLint, GLsizei, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLfloat_array(count*4, value);
    gl_glUniform4fv(location, count, value);

glUniform1iv: void, GLint, GLsizei, GLint+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLint_array(count, value);
    gl_glUniform1iv(location, count, value);

glUniform2iv: void, GLint, GLsizei, GLint+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLint_array(count*2, value);
    gl_glUniform2iv(location, count, value);

glUniform3iv: void, GLint, GLsizei, GLint+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLint_array(count*3, value);
    gl_glUniform3iv(location, count, value);

glUniform4iv: void, GLint, GLsizei, GLint+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLint_array(count*4, value);
    gl_glUniform4iv(location, count, value);

glUniform1uiv: void, GLint, GLsizei, GLuint+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLuint_array(count, value);
    gl_glUniform1uiv(location, count, value);

glUniform2uiv: void, GLint, GLsizei, GLuint+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLuint_array(count*2, value);
    gl_glUniform2uiv(location, count, value);

glUniform3uiv: void, GLint, GLsizei, GLuint+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLuint_array(count*3, value);
    gl_glUniform3uiv(location, count, value);

glUniform4uiv: void, GLint, GLsizei, GLuint+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLuint_array(count*4, value);
    gl_glUniform4uiv(location, count, value);

glUniformMatrix2fv: void, GLint, GLsizei, GLboolean, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLboolean(transpose);
    gl_param_GLfloat_array(count*4, value);
    gl_glUniformMatrix2fv(location, count, transpose, value);

glUniformMatrix3fv: void, GLint, GLsizei, GLboolean, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLboolean(transpose);
    gl_param_GLfloat_array(count*9, value);
    gl_glUniformMatrix3fv(location, count, transpose, value);

glUniformMatrix4fv: void, GLint, GLsizei, GLboolean, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLboolean(transpose);
    gl_param_GLfloat_array(count*16, value);
    gl_glUniformMatrix4fv(location, count, transpose, value);

glUniformMatrix2x3fv: void, GLint, GLsizei, GLboolean, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLboolean(transpose);
    gl_param_GLfloat_array(count*6, value);
    gl_glUniformMatrix2x3fv(location, count, transpose, value);

glUniformMatrix3x2fv: void, GLint, GLsizei, GLboolean, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLboolean(transpose);
    gl_param_GLfloat_array(count*6, value);
    gl_glUniformMatrix3x2fv(location, count, transpose, value);

glUniformMatrix2x4fv: void, GLint, GLsizei, GLboolean, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLboolean(transpose);
    gl_param_GLfloat_array(count*8, value);
    gl_glUniformMatrix2x4fv(location, count, transpose, value);

glUniformMatrix4x2fv: void, GLint, GLsizei, GLboolean, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLboolean(transpose);
    gl_param_GLfloat_array(count*8, value);
    gl_glUniformMatrix4x2fv(location, count, transpose, value);

glUniformMatrix3x4fv: void, GLint, GLsizei, GLboolean, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLboolean(transpose);
    gl_param_GLfloat_array(count*12, value);
    gl_glUniformMatrix3x4fv(location, count, transpose, value);

glUniformMatrix4x3fv: void, GLint, GLsizei, GLboolean, GLfloat+array
    gl_param_GLint(location);
    gl_param_GLsizei(count);
    gl_param_GLboolean(transpose);
    gl_param_GLfloat_array(count*12, value);
    gl_glUniformMatrix4x3fv(location, count, transpose, value);

glTestFBWIP15: void, string, data, data
    gl_param_string(name);
    gl_param_data(drawable_width*drawable_height*4, color);
    gl_param_data(drawable_width*drawable_height*4, depth);

glCurrentTestWIP15: void, string
    gl_param_string(name);

glGenVertexArrays: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_glGenVertexArrays(n, arrays);
    gl_param_GLuint_array(n, arrays);

glDeleteVertexArrays: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_param_GLuint_array(n, arrays);
    gl_glDeleteVertexArrays(n, arrays);

glPatchParameterfv: void, GLenum, GLfloat+array
    gl_param_GLenum(pname); //TODO: The group
    switch (pname) {
    case GL_PATCH_VERTICES:
        gl_param_GLfloat_array(1, values);
        break;
    case GL_PATCH_DEFAULT_OUTER_LEVEL:
        gl_param_GLfloat_array(4, values);
        break;
    case GL_PATCH_DEFAULT_INNER_LEVEL:
        gl_param_GLfloat_array(2, values);
        break;
    }
    gl_glPatchParameterfv(pname, values);

glDrawableSizeWIP15: void, GLsizei, GLsizei
    gl_param_GLsizei(width);
    gl_param_GLsizei(height);

glGetBufferParameteriv: void, GLenum, GLenum, GLint
    gl_glGetBufferParameteriv(target, pname, params);
    gl_param_GLenum(target); //TODO: The group
    gl_param_GLenum(pname); //TODO: The group
    gl_param_GLint(*params);

glGetBufferPointerv: void, GLenum, GLenum, pointer
    gl_glGetBufferPointerv(target, pname, params);
    gl_param_GLenum(target); //TODO: The group
    gl_param_GLenum(pname); //TODO: The group
    gl_param_pointer(*params);

glGenSamplers: void, GLsizei, GLuint+array
    gl_param_GLsizei(count);
    gl_glGenSamplers(count, samplers);
    gl_param_GLuint_array(count, samplers);

glDeleteSamplers: void, GLsizei, GLuint+array
    gl_param_GLsizei(count);
    gl_param_GLuint_array(count, samplers);
    gl_glDeleteSamplers(count, samplers);

glPointParameterfv: void, GLenum, GLfloat
    gl_param_GLenum(pname); //TODO: The group
    gl_param_GLfloat(*params);
    gl_glPointParameterfv(pname, params);

glPointParameteriv: void, GLenum, GLint
    gl_param_GLenum(pname); //TODO: The group
    gl_param_GLint(*params);
    gl_glPointParameteriv(pname, params);

glGetSynciv: void, GLsync, GLenum, GLsizei, GLsizei, GLint+array
    GLsizei len;
    gl_glGetSynciv(sync, pname, bufSize, length?length:&len, values);
    
    gl_param_GLsync(sync);
    gl_param_GLenum(pname);
    gl_param_GLsizei(bufSize);
    if (length) {
        gl_param_GLsizei(*length);
        gl_param_GLint_array(*length, values);
    } else {
        gl_param_GLsizei(len);
        gl_param_GLint_array(len, values);
    }

glMultiDrawArrays: void, GLenum+group, GLint+array, GLint+array, GLsizei
    gl_param_GLenum(mode);
    gl_write_group(GROUP_PrimitiveType);
    gl_param_GLint_array(drawcount, first);
    gl_param_GLint_array(drawcount, count);
    gl_param_GLsizei(drawcount);
    gl_glMultiDrawArrays(mode, first, count, drawcount);

glMultiDrawElements: void, GLenum+group, GLint+array, GLenum, pointer+array, GLsizei
    gl_param_GLenum(mode);
    gl_write_group(GROUP_PrimitiveType);
    gl_param_GLint_array(drawcount, count);
    gl_param_GLenum(type); //TODO: The group
    gl_param_pointer_array(drawcount, indices);
    gl_param_GLsizei(drawcount);
    gl_glMultiDrawElements(mode, count, type, indices, drawcount);

glMultiDrawElementsBaseVertex: void, GLenum+group, GLint+array, GLenum, pointer+array, GLsizei, GLint+array
    gl_param_GLenum(mode);
    gl_write_group(GROUP_PrimitiveType);
    gl_param_GLint_array(drawcount, count);
    gl_param_GLenum(type); //TODO: The group
    gl_param_pointer_array(drawcount, indices);
    gl_param_GLsizei(drawcount);
    gl_param_GLint_array(drawcount, basevertex);
    gl_glMultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex);

glSamplerParameterfv: void, GLuint, GLenum, GLfloat+array
    gl_glSamplerParameterfv(sampler, pname, param);
    gl_param_GLuint(sampler);
    gl_param_GLenum(pname); //TODO: The group
    if (pname == GL_TEXTURE_BORDER_COLOR)
        gl_param_GLfloat_array(4, param);
    else
        gl_param_GLfloat_array(1, param);

glSamplerParameteriv: void, GLuint, GLenum, GLint+array
    gl_glSamplerParameteriv(sampler, pname, param);
    gl_param_GLuint(sampler);
    gl_param_GLenum(pname); //TODO: The group
    if (pname == GL_TEXTURE_BORDER_COLOR)
        gl_param_GLint_array(4, param);
    else
        gl_param_GLint_array(1, param);

glSamplerParameterIiv: void, GLuint, GLenum, GLint+array
    gl_glSamplerParameterIiv(sampler, pname, param);
    gl_param_GLuint(sampler);
    gl_param_GLenum(pname); //TODO: The group
    if (pname == GL_TEXTURE_BORDER_COLOR)
        gl_param_GLint_array(4, param);
    else
        gl_param_GLint_array(1, param);

glSamplerParameterIuiv: void, GLuint, GLenum, GLuint+array
    gl_glSamplerParameterIuiv(sampler, pname, param);
    gl_param_GLuint(sampler);
    gl_param_GLenum(pname); //TODO: The group
    if (pname == GL_TEXTURE_BORDER_COLOR)
        gl_param_GLuint_array(4, param);
    else
        gl_param_GLuint_array(1, param);

glGenFramebuffers: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_glGenFramebuffers(n, framebuffers);
    gl_param_GLuint_array(n, framebuffers);

glDeleteFramebuffers: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_param_GLuint_array(n, framebuffers);
    gl_glDeleteFramebuffers(n, framebuffers);

glGenRenderbuffers: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_glGenRenderbuffers(n, renderbuffers);
    gl_param_GLuint_array(n, renderbuffers);

glDeleteRenderbuffers: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_param_GLuint_array(n, renderbuffers);
    gl_glDeleteRenderbuffers(n, renderbuffers);

glGetActiveUniformsiv: void, GLuint, GLsizei, GLuint+array, GLenum, GLint+array
    gl_glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
    gl_param_GLuint(program);
    gl_param_GLsizei(uniformCount);
    gl_param_GLuint_array(uniformCount, uniformIndices);
    gl_param_GLenum(pname); //TODO: The group
    gl_param_GLint_array(uniformCount, params);

glGetFramebufferAttachmentParameteriv: void, GLenum, GLenum, GLenum, GLint
    gl_glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
    gl_param_GLenum(target); //TODO: The group
    gl_param_GLenum(attachment); //TODO: The group
    gl_param_GLenum(pname); //TODO: The group
    gl_param_GLint(*params);

glGetRenderbufferParameteriv: void, GLenum, GLenum, GLint
    gl_glGetRenderbufferParameteriv(target, pname, params);
    gl_param_GLenum(target); //TODO: The group
    gl_param_GLenum(pname); //TODO: The group
    gl_param_GLint(*params);

glGenQueries: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_glGenQueries(n, ids);
    gl_param_GLuint_array(n, ids);

glDeleteQueries: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_param_GLuint_array(n, ids);
    gl_glDeleteQueries(n, ids);

glDrawBuffers: void, GLsizei, GLuint+array
    gl_param_GLsizei(n);
    gl_param_GLuint_array(n, bufs);
    gl_glDrawBuffers(n, bufs);

glClearBufferiv: void, GLenum, GLint, GLint+array
    gl_param_GLenum(buffer); //TODO: The group
    gl_param_GLint(drawbuffer); //TODO: The group
    gl_param_GLint_array(buffer==GL_COLOR?4:1, value);

glClearBufferuiv: void, GLenum, GLint, GLuint+array
    gl_param_GLenum(buffer); //TODO: The group
    gl_param_GLint(drawbuffer); //TODO: The group
    gl_param_GLuint_array(buffer==GL_COLOR?4:1, value);

glClearBufferfv: void, GLenum, GLint, GLfloat+array
    gl_param_GLenum(buffer); //TODO: The group
    gl_param_GLint(drawbuffer); //TODO: The group
    gl_param_GLfloat_array(buffer==GL_COLOR?4:1, value);
