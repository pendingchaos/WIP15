glXChooseVisual:
    gl_param_pointer(dpy);
    gl_param_int(screen, -1);
    int *attribs = attribList;
    while (*attribs != None) ++attribs;
    gl_param_GLuint_array(attribs-attribList+1, attribList);
    XVisualInfo* result = gl_glXChooseVisual(dpy, screen, attribList);
    gl_result_pointer(result);

glGenTextures:
    gl_param_GLsizei(n, -1);
    gl_glGenTextures(n, textures);
    gl_param_GLuint_array(n, textures);

glDeleteTextures:
    gl_param_GLsizei(n, -1);
    gl_param_GLuint_array(n, textures);
    gl_glDeleteTextures(n, textures);

glTexImage2D:
    size_t components = 0;
    
    switch (format) {
    case GL_COLOR_INDEX:
    case GL_RED:
    case GL_GREEN:
    case GL_BLUE:
    case GL_ALPHA:
    case GL_LUMINANCE:
    case GL_STENCIL_INDEX:
    case GL_DEPTH_COMPONENT: {
        components = 1;
        break;
    }
    case GL_DEPTH_STENCIL: {
        //TODO
        break;
    }
    case GL_RG:
    case GL_RG_INTEGER:
    case GL_LUMINANCE_ALPHA: {
        components = 2;
        break;
    }
    case GL_RGB:
    case GL_RGB_INTEGER:
    case GL_BGR_INTEGER:
    case GL_BGR: {
        components = 3;
        break;
    }
    case GL_RGBA:
    case GL_RGBA_INTEGER:
    case GL_BGRA_INTEGER:
    case GL_BGRA: {
        components = 4;
        break;
    }
    }
    
    size_t final_size = 0;
    switch (type) {
    case GL_UNSIGNED_BYTE:
    case GL_BYTE: {
        final_size = components;
        break;
    }
    case GL_BITMAP: {
        //TODO
        final_size = 0;
        break;
    }
    case GL_UNSIGNED_SHORT:
    case GL_SHORT: {
        final_size = components * 2;
        break;
    }
    case GL_UNSIGNED_INT:
    case GL_INT:
    case GL_FLOAT: {
        final_size = components * 4;
        break;
    }
    case GL_UNSIGNED_BYTE_3_3_2:
    case GL_UNSIGNED_BYTE_2_3_3_REV: {
        final_size = 1;
        break;
    }
    case GL_UNSIGNED_SHORT_5_6_5:
    case GL_UNSIGNED_SHORT_5_6_5_REV:
    case GL_UNSIGNED_SHORT_5_5_5_1:
    case GL_UNSIGNED_SHORT_1_5_5_5_REV:
    case GL_UNSIGNED_SHORT_4_4_4_4:
    case GL_UNSIGNED_SHORT_4_4_4_4_REV: {
        final_size = 2;
        break;
    }
    case GL_UNSIGNED_INT_8_8_8_8_REV:
    case GL_UNSIGNED_INT_10_10_10_2:
    case GL_UNSIGNED_INT_2_10_10_10_REV: {
        final_size = 4;
        break;
    }
    }
    
    GLint alignment;
    if (!gl_glGetIntegerv)
        gl_glGetIntegerv = (glGetIntegerv_t)gl_glXGetProcAddress((const GLubyte*)"glGetIntegerv");
    gl_glGetIntegerv(GL_UNPACK_ALIGNMENT, &alignment);
    
    if (final_size) {
        size_t base = final_size / alignment * alignment;
        size_t extra = final_size - base;
        final_size = base + (extra?alignment:0);
    }
    
    gl_param_GLenum(target, GROUP_TextureTarget);
    gl_param_GLint(level, -1);
    gl_param_GLint(internalformat, GROUP_InternalFormat);
    gl_param_GLsizei(width, -1);
    gl_param_GLsizei(height, -1);
    gl_param_GLint(border, -1);
    gl_param_GLenum(format, GROUP_PixelFormat); 
    gl_param_GLenum(type, GROUP_PixelType);
    
    if (pixels) {
        gl_param_data(width*height*final_size, pixels);
    } else {
        void* data = malloc(width*height*final_size);
        gl_param_data(width*height*final_size, data);
        free(data);
    }
    
    gl_glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);

glGenBuffers:
    gl_param_GLsizei(n, -1);
    gl_glGenBuffers(n, buffers);
    gl_param_GLuint_array(n, buffers);

glDeleteBuffers:
    gl_param_GLsizei(n, -1);
    gl_param_GLuint_array(n, buffers);
    gl_glDeleteBuffers(n, buffers);

glBufferData:
    gl_param_GLenum(target, -1); //TODO: The group
    gl_param_GLsizeiptr(size, -1);
    
    if (data) {
        gl_param_data(size, data);
    } else {
        void* ptr = malloc(size);
        gl_param_data(size, ptr);
        free(ptr);
    }
    
    gl_param_GLenum(usage, -1); //TODO: The group
    
    gl_glBufferData(target, size, data, usage);

glBufferSubData:
    gl_param_GLenum(target, -1); //TODO: The group
    gl_param_GLintptr(offset, -1);
    gl_param_GLsizeiptr(size, -1);
    gl_param_data(size, data);
    
    gl_glBufferSubData(target, offset, size, data);

glVertexPointer:
    gl_param_GLint(size, -1);
    gl_param_GLenum(type, GROUP_VertexPointerType);
    gl_param_GLsizei(stride, -1);
    
    GLint buffer;
    gl_glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &buffer);
    
    if (buffer) {
        gl_param_pointer(pointer);
    } else {
        //TODO
    }
    
    gl_glVertexPointer(size, type, stride, pointer);

glTexCoordPointer:
    gl_param_GLint(size, -1);
    gl_param_GLenum(type, GROUP_TexCoordPointerType);
    gl_param_GLsizei(stride, -1);
    
    GLint buffer;
    gl_glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &buffer);
    
    if (buffer) {
        gl_param_pointer(pointer);
    } else {
        //TODO
    }
    
    gl_glTexCoordPointer(size, type, stride, pointer);

glLoadMatrixd:
    gl_param_double_array(16, m);
    gl_glLoadMatrixd(m);

glLoadMatrixf:
    double arr[16];
    for (size_t i = 0; i < 16; ++i) arr[i] = m[i];
    gl_param_double_array(16, arr);
    gl_glLoadMatrixf(m);

glLoadTransposeMatrixd:
    gl_param_double_array(16, m);
    gl_glLoadTransposeMatrixd(m);

glLoadTransposeMatrixf:
    double arr[16];
    for (size_t i = 0; i < 16; ++i) arr[i] = m[i];
    gl_param_double_array(16, arr);
    gl_glLoadTransposeMatrixf(m);

glMultMatrixd:
    gl_param_double_array(16, m);
    gl_glMultMatrixd(m);

glMultMatrixf:
    double arr[16];
    for (size_t i = 0; i < 16; ++i) arr[i] = m[i];
    gl_param_double_array(16, arr);
    gl_glMultMatrixf(m);

glMultTransposeMatrixd:
    gl_param_double_array(16, m);
    gl_glMultTransposeMatrixd(m);

glMultTransposeMatrixf:
    double arr[16];
    for (size_t i = 0; i < 16; ++i) arr[i] = m[i];
    gl_param_double_array(16, arr);
    gl_glMultTransposeMatrixf(m);
