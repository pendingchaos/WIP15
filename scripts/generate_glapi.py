#!/usr/bin/env python
# -*- coding: utf-8 -*-
import glxml

class Function(object):
    def __init__(self, func):
        self.versions = []
        self.extension = None
        self.func = func

class GroupEntry(object):
    def __init__(self, name, value):
        self.name = name
        self.value = value
        self.versions = [(1, 0)]
        self.extension = None

class Group(object):
    def __init__(self, group, glxml):
        self.group = group
        self.entries = []
        
        for v in self.group.enumNames:
            self.entries.append(GroupEntry(v, glxml.enumValues[v]))

gl = glxml.GL(False)

output = open("../src/glapi.h", "w")

output.write("""//Generated by generate_glapi.py. Do not edit. Edit generate_glapi.py instead.
#ifndef GLAPI_H
#define GLAPI_H

#include <stddef.h>
#include <stdbool.h>

typedef enum {
    glnone = 0,
    gl1_0 = 1 << 0,
    gl1_1 = 1 << 1,
    gl1_2 = 1 << 2,
    gl1_2_1 = 1 << 3,
    gl1_3 = 1 << 4,
    gl1_4 = 1 << 5,
    gl1_5 = 1 << 6,
    gl2_0 = 1 << 7,
    gl2_1 = 1 << 8,
    gl3_0 = 1 << 9,
    gl3_1 = 1 << 10,
    gl3_2 = 1 << 11,
    gl3_3 = 1 << 12,
    gl4_0 = 1 << 13,
    gl4_1 = 1 << 14,
    gl4_2 = 1 << 15,
    gl4_3 = 1 << 16,
    gl4_4 = 1 << 17,
    gl4_5 = 1 << 18
} glapi_version_mask_t;

typedef struct {
    glapi_version_mask_t version; //Can be 0
    const char* extension; //Can be NULL
    bool compatibility;
    bool core;
} glapi_requirements_t;

typedef struct {
    const glapi_requirements_t* requirements;
    unsigned int value;
    const char* name;
} glapi_group_entry_t;

typedef struct {
    bool bitmask;
    const char *name;
    size_t entry_count;
    const glapi_group_entry_t** entries;
} glapi_group_t;

typedef struct {
    const char* name;
    const glapi_group_t* group; //Can be NULL
} glapi_arg_t;

typedef struct {
    const glapi_requirements_t* requirements;
    const char *name;
    size_t arg_count;
    const glapi_arg_t** args;
} glapi_function_t;

typedef struct {
    size_t group_count;
    glapi_group_t** groups;
    
    size_t function_count;
    glapi_function_t** functions;
} glapi_t;

extern const glapi_t glapi;
#endif
""")

versions = [(1, 0),
            (1, 1),
            (1, 2),
            (1, 3),
            (1, 4),
            (1, 5),
            (2, 0),
            (2, 1),
            (3, 0),
            (3, 1),
            (3, 2),
            (3, 3),
            (4, 0),
            (4, 1),
            (4, 2),
            (4, 3),
            (4, 4),
            (4, 5)]

ver_to_mask = {(1, 0):"gl1_0",
               (1, 1):"gl1_1",
               (1, 2):"gl1_2",
               (1, 3):"gl1_3",
               (1, 4):"gl1_4",
               (1, 5):"gl1_5",
               (2, 0):"gl2_0",
               (2, 1):"gl2_1",
               (3, 0):"gl3_0",
               (3, 1):"gl3_1",
               (3, 2):"gl3_2",
               (3, 3):"gl3_3",
               (4, 0):"gl4_0",
               (4, 1):"gl4_1",
               (4, 2):"gl4_2",
               (4, 3):"gl4_3",
               (4, 4):"gl4_4",
               (4, 5):"gl4_5"}

functions = {}
groups = {}

for k, v in gl.functions.iteritems():
    functions[k] = Function(v)

for k, v in gl.groups.iteritems():
    groups[k] = Group(v, gl)

for ver_num in versions:
    ver = gl.versions[ver_num]
    vers = versions[versions.index(ver_num):]
    
    for func in ver.new_functions:
        for other_ver in vers:
            functions[func].versions.append(other_ver)
    
    for enum in ver.new_enums:
        for other_ver in vers:
            for group in groups.values():
                for entry in group.entries:
                    if entry.name == enum:
                        entry.versions.append(other_ver)
    
    for func in ver.removed_functions:
        for other_ver in vers:
            functions[func].versions.remove(other_ver)
    
    for enum in ver.removed_enums:
        for other_ver in vers:
            for group in groups.values():
                for entry in group.entries:
                    if entry.name == enum:
                        entry.versions.remove(other_ver)

for k, v in gl.extensions.iteritems():
    for func in v.functions:
        if not func.startswith("glX"):
            functions[func].extension = k
    
    for enum in v.enums:
        for group in groups.values():
            for entry in group.entries:
                if entry.name == enum:
                    entry.extension = k

output = open("../src/glapi.c", "w")

output.write("""//Generated by generate_glapi.py. Do not edit. Edit generate_glapi.py instead.
#include "glapi.h"

""")

next_req_id = 0

i = 0
for name, group in groups.iteritems():
    for entry in group.entries:
        ver_mask = "|".join([ver_to_mask[ver] for ver in entry.versions])
        if len(ver_mask) == 0:
            ver_mask = "glnone"
        
        ext = ("\"%s\"" % entry.extension) if entry.extension != None else "NULL"
        
        output.write("static const glapi_requirements_t req_%d = {%s, %s, %s, %s};\n" %
                     (next_req_id,
                      ver_mask,
                      ext,
                      "true",
                      "true"))
        
        output.write("static const glapi_group_entry_t entry_%d = {&req_%d, %d, \"%s\"};\n" %
                     (id(entry),
                      next_req_id,
                      entry.value,
                      entry.name))
        
        next_req_id += 1
    
    output.write("static const glapi_group_entry_t* entries_%d[] = {%s};\n" %
                 (i,
                  ", ".join(["&entry_%d" % id(entry) for entry in group.entries])))
    
    output.write("static const glapi_group_t group_%d = {%s, \"%s\", %d, entries_%d};\n" %
                 (id(group),
                  "true" if group.group.bitmask else "false",
                  name,
                  len(group.entries),
                  i))
    
    i += 1

i = 0
for name, func in functions.iteritems():
    for arg in func.func.params:
        group = ("&group_%d" % id(groups[arg.group])) if arg.group != None else "NULL"
        
        output.write("static const glapi_arg_t arg_%d = {\"%s\", %s};\n" %
                     (id(arg),
                      arg.name,
                      group))
    
    ver_mask = "|".join([ver_to_mask[ver] for ver in func.versions])
    if len(ver_mask) == 0:
        ver_mask = "glnone"
    
    ext = ("\"%s\"" % func.extension) if func.extension != None else "NULL"
    
    output.write("static const glapi_arg_t* args_%d[] = {%s};\n" %
                 (i,
                  ", ".join(["&arg_%d" % id(arg) for arg in func.func.params])))
    
    output.write("static const glapi_requirements_t req_%d = {%s, %s, %s, %s};\n" %
                 (next_req_id,
                  ver_mask,
                  ext,
                  "true",
                  "true"))
    
    output.write("static const glapi_function_t func_%d = {&req_%d, \"%s\", %d, args_%d};\n" %
                 (id(func),
                  next_req_id,
                  name,
                  len(func.func.params),
                  i))
    
    next_req_id += 1
    
    i += 1

output.write("static glapi_group_t*const* groups[] = {%s};\n" %
             ", ".join(["&group_%d" % id(group) for group in groups.values()]))

output.write("static glapi_function_t** funcs[] = {%s};\n" %
             ", ".join(["&func_%d" % id(func) for func in functions.values()]))

output.write("const glapi_t glapi = {%d, groups, %d, funcs};\n" %
             (len(groups),
              len(functions)))
