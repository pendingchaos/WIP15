#Generates src/libtrace/libtrace_glstate.h
import sys

src = '''
uint drawable_width
uint drawable_height

map buffer bound_buffer
    GL_ARRAY_BUFFER
    GL_ATOMIC_COUNTER_BUFFER
    GL_COPY_READ_BUFFER
    GL_COPY_WRITE_BUFFER
    GL_DISPATCH_INDIRECT_BUFFER
    GL_DRAW_INDIRECT_BUFFER
    GL_ELEMENT_ARRAY_BUFFER
    GL_PIXEL_PACK_BUFFER
    GL_PIXEL_UNPACK_BUFFER
    GL_QUERY_BUFFER
    GL_SHADER_STORAGE_BUFFER
    GL_TEXTURE_BUFFER
    GL_TRANSFORM_FEEDBACK_BUFFER
    GL_UNIFORM_BUFFER

program bound_program

vao bound_vao

renderbuffer bound_renderbuffer

framebuffer read_framebuffer
framebuffer draw_framebuffer

map array query bound_queries
    GL_SAMPLES_PASSED
    GL_ANY_SAMPLES_PASSED
    GL_ANY_SAMPLES_PASSED_CONSERVATIVE
    GL_PRIMITIVES_GENERATED
    GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
    GL_TIME_ELAPSED

uint active_texture_unit
map array texture bound_textures
    GL_TEXTURE_1D
    GL_TEXTURE_2D
    GL_TEXTURE_3D
    GL_TEXTURE_1D_ARRAY
    GL_TEXTURE_2D_ARRAY
    GL_TEXTURE_RECTANGLE
    GL_TEXTURE_CUBE_MAP
    GL_TEXTURE_CUBE_MAP_ARRAY
    GL_TEXTURE_BUFFER
    GL_TEXTURE_2D_MULTISAMPLE
    GL_TEXTURE_2D_MULTISAMPLE_ARRAY

array uint8 front_color_buffer
array uint8 back_color_buffer
array uint8 back_depth_buffer
array uint8 back_stencil_buffer

//Used for draw calls
uint draw_vao
'''

class Property(object):
    def __init__(self, map, array, base, name, map_keys=[]):
        self.map = map
        self.array = array
        self.base = base
        self.name = name
        self.map_keys = map_keys
        self.get_func_sig = ''
        self.set_func_sig = ''
        self.size_func_sig = ''
        self.init_func_sig = ''
        self.insert_func_sig = ''
        self.erase_func_sig = ''
        self.c_type = {'uint': 'uint',
                       'uint8': 'uint8_t',
                       'texture': 'uint',
                       'buffer': 'uint',
                       'program': 'uint',
                       'vao': 'uint',
                       'query': 'uint',
                       'renderbuffer': 'uint',
                       'framebuffer': 'uint'}[base]

lines = src.split('\n')
properties = []
while len(lines):
    line = lines.pop(0)
    if line == '': continue
    if line.startswith('//'): continue
    types = line.split(' ')[:-1]
    name = line.split(' ')[-1]
    map = 'map' in types
    if map: types.remove('map')
    array = 'array' in types
    if array: types.remove('array')
    base = types[0]
    map_keys = []
    if map:
        while len(lines) and lines[0].startswith('    '):
            map_keys.append(lines.pop(0)[4:])
    properties.append(Property(map, array, base, name, map_keys))

for prop in properties:
    sig = prop.c_type + ' trc_gl_state_get_%s(trace_t* trace' % prop.name
    if prop.map:
        sig += ', uint key'
    if prop.array:
        sig += ', size_t index'
    sig += ')'
    prop.get_func_sig = sig
    
    sig = 'void trc_gl_state_set_%s(trace_t* trace, ' % prop.name
    if prop.map:
        sig += 'uint key, '
    if prop.array:
        sig += 'size_t index, '
    sig += prop.c_type + ' val)'
    prop.set_func_sig = sig
    
    if prop.array:
        sig = 'size_t trc_gl_state_get_%s_size(trace_t* trace' % prop.name
        if prop.map:
            sig += ', uint key'
        sig += ')'
        prop.size_func_sig = sig
        
        sig = 'void trc_gl_state_%s_init(trace_t* trace' % prop.name
        if prop.map:
            sig += ', uint key'
        sig += ', size_t count, const %s* data)' % prop.c_type
        prop.init_func_sig = sig
        
        sig = 'void trc_gl_state_%s_insert(trace_t* trace' % prop.name
        if prop.map:
            sig += ', uint key'
        sig += ', size_t before, %s value)' % prop.c_type
        prop.insert_func_sig = sig
        
        sig = 'void trc_gl_state_%s_erase(trace_t* trace' % prop.name
        if prop.map:
            sig += ', uint key'
        sig += ', size_t index)'
        prop.erase_func_sig = sig

output = open('../src/libtrace/libtrace_glstate.h', 'w')
sys.stdout = output

print '//Generated by genereate_libtrace_glstate.py'
print '//Do not edit. Edit generate_libtrace_glstate.py instead'
print '#ifdef WIP15_STATE_GEN_DECL'
print 'typedef struct trc_gl_context_rev_t {'
print '    uint64_t revision;'
print '    void* real;'
print '    '
for prop in properties:
    c_type = prop.c_type
    if prop.array:
        c_type = 'trc_data_t*'
    if prop.map:
        for key in prop.map_keys:
            print '    %s %s_%s;' % (c_type, prop.name, key)
    else:
        print '    %s %s;' % (c_type, prop.name)
print '} trc_gl_context_rev_t;'
print '#endif'
print

print '#ifdef WIP15_STATE_GEN_FUNC_DECL'
for prop in properties:
    print prop.get_func_sig + ';'
    print prop.set_func_sig + ';'
    if prop.array:
        print prop.size_func_sig + ';'
        print prop.init_func_sig + ';'
        print prop.insert_func_sig + ';'
print '#endif'
print

print '#ifdef WIP15_STATE_GEN_IMPL'
print '#include <GL/gl.h>'
print
for prop in properties:
    print prop.get_func_sig + ' {'
    if prop.map:
        if prop.array:
            print '    trc_data_t* arr = NULL;'
        print '    switch (key) {'
        for key in prop.map_keys:
            if prop.array:
                print '    case %s: arr = trc_get_gl_context(trace, 0)->%s_%s; break;' % (key, prop.name, key)
            else:
                print '    case %s: return trc_get_gl_context(trace, 0)->%s_%s;' % (key, prop.name, key)
        print '    }'
    elif prop.array:
        print '    trc_data_t* arr = trc_get_gl_context(trace, 0)->%s;' % prop.name
    else:
        print '    return trc_get_gl_context(trace, 0)->%s;' % prop.name
    if prop.array:
        print '    %s* data = trc_lock_data(arr, true, false);' % prop.c_type
        print '    %s res = data[index];' % (prop.c_type)
        print '    trc_unlock_data(arr);'
        print '    return res;'
    print '}'
    print

for prop in properties:
    print prop.set_func_sig + ' {'
    print '    trc_gl_context_rev_t state = *trc_get_gl_context(trace, 0);'
    if prop.map:
        if prop.array:
            print '    trc_data_t** arr = NULL;'
        print '    switch (key) {'
        for key in prop.map_keys:
            if prop.array:
                print '    case %s: arr = &state.%s_%s; break;' % (key, prop.name, key)
            else:
                print '    case %s: state.%s_%s = val; break;' % (key, prop.name, key)
        print '    }'
    elif prop.array:
        print '    trc_data_t** arr = &state.%s;' % prop.name
    else:
        print '    state.%s = val;' % prop.name
    if prop.array:
        print '    void* olddata = trc_lock_data(*arr, true, false);'
        print '    trc_data_t* newdata = trc_create_inspection_data(trace, (*arr)->uncompressed_size, olddata);'
        print '    trc_unlock_data(*arr);'
        print '    %s* data = trc_lock_data(newdata, false, true);' % prop.c_type
        print '    data[index] = val;'
        print '    trc_unlock_data(newdata);'
        print '    *arr = newdata;'
    print '    trc_set_gl_context(trace, 0, &state);'
    print '}'
    print

for prop in properties:
    if not prop.array: continue
    
    print prop.size_func_sig + ' {'
    if prop.map:
        print '    switch (key) {'
        for key in prop.map_keys:
            print '    case %s: return trc_get_gl_context(trace, 0)->%s_%s->uncompressed_size / sizeof(%s);' % (key, prop.name, key, prop.c_type)
        print '    }'
    else:
        print '    return trc_get_gl_context(trace, 0)->%s->uncompressed_size / sizeof(%s);' % (prop.name, prop.c_type)
    print '}'
    print
    
    print prop.init_func_sig + ' {'
    print '    trc_gl_context_rev_t state = *trc_get_gl_context(trace, 0);'
    if prop.map:
        print '    trc_data_t** arr = NULL;'
        print '    switch (key) {'
        for key in prop.map_keys:
            print '    case %s: arr = &state.%s_%s; break;' % (key, prop.name, key)
        print '    }'
    else:
        print '    trc_data_t** arr = &state.%s;' % prop.name;
    print '    *arr = trc_create_inspection_data(trace, count*sizeof(%s), data);' % prop.c_type
    print '    trc_set_gl_context(trace, 0, &state);'
    print '}'
    print
    
    print prop.insert_func_sig + ' {'
    print '    trc_gl_context_rev_t state = *trc_get_gl_context(trace, 0);'
    if prop.map:
        print '    trc_data_t** arr = NULL;'
        print '    switch (key) {'
        for key in prop.map_keys:
            print '    case %s: arr = &state.%s_%s; break;' % (key, prop.name, key)
        print '    }'
    else:
        print '    trc_data_t** arr = &state.%s;' % prop.name;
    print '    size_t count = (*arr)->uncompressed_size / sizeof(%s);' % prop.c_type
    print '    trc_data_t* newarr = trc_create_inspection_data(trace, (count+1)*sizeof(%s), NULL);' % prop.c_type
    print '    %s* olddata = trc_lock_data(*arr, true, false);' % prop.c_type
    print '    %s* newdata = trc_lock_data(newarr, false, true);' % prop.c_type
    print '    memcpy(newdata, olddata, before*sizeof(%s));' % prop.c_type
    print '    newdata[before] = value;'
    print '    memcpy(newdata+before+1, olddata+before, (count-before)*sizeof(%s));' % prop.c_type
    print '    trc_unlock_data(newarr);'
    print '    trc_unlock_data(*arr);'
    print '    *arr = newarr;'
    print '    trc_set_gl_context(trace, 0, &state);'
    print '}'
    print
    
    print prop.erase_func_sig + ' {'
    print '    trc_gl_context_rev_t state = *trc_get_gl_context(trace, 0);'
    if prop.map:
        print '    trc_data_t** arr = NULL;'
        print '    switch (key) {'
        for key in prop.map_keys:
            print '    case %s: arr = &state.%s_%s; break;' % (key, prop.name, key)
        print '    }'
    else:
        print '    trc_data_t** arr = &state.%s;' % prop.name;
    print '    size_t count = (*arr)->uncompressed_size / sizeof(%s);' % prop.c_type
    print '    trc_data_t* newarr = trc_create_inspection_data(trace, (count-1)*sizeof(%s), NULL);' % prop.c_type
    print '    %s* olddata = trc_lock_data(*arr, true, false);' % prop.c_type
    print '    %s* newdata = trc_lock_data(newarr, false, true);' % prop.c_type
    print '    memcpy(newdata, olddata, index*sizeof(%s));' % prop.c_type
    print '    memcpy(newdata+index, olddata+index+1, (count-index-1)*sizeof(%s));' % prop.c_type
    print '    trc_unlock_data(newarr);'
    print '    trc_unlock_data(*arr);'
    print '    *arr = newarr;'
    print '    trc_set_gl_context(trace, 0, &state);'
    print '}'
    print
print '#endif'

output.close()
